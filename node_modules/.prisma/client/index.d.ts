import {
  DMMF,
  DMMFClass,
  Engine,
  PrismaClientKnownRequestError,
  PrismaClientUnknownRequestError,
  PrismaClientRustPanicError,
  PrismaClientInitializationError,
  PrismaClientValidationError,
  sqltag as sql,
  empty,
  join,
  raw,
} from '@prisma/client/runtime';

export { PrismaClientKnownRequestError }
export { PrismaClientUnknownRequestError }
export { PrismaClientRustPanicError }
export { PrismaClientInitializationError }
export { PrismaClientValidationError }

/**
 * Re-export of sql-template-tag
 */
export { sql, empty, join, raw }

/**
 * Prisma Client JS version: 2.0.0
 * Query Engine version: de2bc1cbdb5561ad73d2f08463fa2eec48993f56
 */
export declare type PrismaVersion = {
  client: string
}

export declare const prismaVersion: PrismaVersion 

/**
 * Utility Types
 */

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON object.
 * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
 */
declare type JsonObject = {[Key in string]?: JsonValue}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON array.
 */
declare interface JsonArray extends Array<JsonValue> {}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches any valid JSON value.
 */
declare type JsonValue = string | number | boolean | null | JsonObject | JsonArray

declare type SelectAndInclude = {
  select: any
  include: any
}

declare type HasSelect = {
  select: any
}

declare type HasInclude = {
  include: any
}

declare type CheckSelect<T, S, U> = T extends SelectAndInclude
  ? 'Please either choose `select` or `include`'
  : T extends HasSelect
  ? U
  : T extends HasInclude
  ? U
  : S

/**
 * Get the type of the value, that the Promise holds.
 */
export declare type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

/**
 * Get the return type of a function which returns a Promise.
 */
export declare type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>


export declare type Enumerable<T> = T | Array<T>;

export declare type TrueKeys<T> = {
  [key in keyof T]: T[key] extends false | undefined | null ? never : key
}[keyof T]

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export declare type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};
declare class PrismaClientFetcher {
  private readonly prisma;
  private readonly debug;
  private readonly hooks?;
  constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
  request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string, collectTimestamps?: any): Promise<T>;
  sanitizeMessage(message: string): string;
  protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
}


/**
 * Client
**/


export type Datasources = {
  postgresql?: string
}

export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

export interface PrismaClientOptions {
  /**
   * Overwrites the datasource url from your prisma.schema file
   */
  datasources?: Datasources

  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat

  /**
   * @example
   * ```
   * // Defaults to stdout
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events
   * log: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * ]
   * ```
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: Array<LogLevel | LogDefinition>

  /**
   * You probably don't want to use this. `__internal` is used by internal tooling.
   */
  __internal?: {
    debug?: boolean
    hooks?: Hooks
    engine?: {
      cwd?: string
      binaryPath?: string
    }
    measurePerformance?: boolean
  }
}

export type Hooks = {
  beforeRequest?: (options: {query: string, path: string[], rootField?: string, typeName?: string, document: any}) => any
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
export type GetEvents<T extends Array<LogLevel | LogDefinition>> = GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]> 

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */

// tested in getLogLevel.test.ts
export declare function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://github.com/prisma/prisma/blob/master/docs/prisma-client-js/api.md).
 */
export declare class PrismaClient<
  T extends PrismaClientOptions = PrismaClientOptions,
  U = keyof T extends 'log' ? T['log'] extends Array<LogLevel | LogDefinition> ? GetEvents<T['log']> : never : never
> {
  /**
   * @private
   */
  private fetcher;
  /**
   * @private
   */
  private readonly dmmf;
  /**
   * @private
   */
  private connectionPromise?;
  /**
   * @private
   */
  private disconnectionPromise?;
  /**
   * @private
   */
  private readonly engineConfig;
  /**
   * @private
   */
  private readonly measurePerformance;
  /**
   * @private
   */
  private engine: Engine;
  /**
   * @private
   */
  private errorFormat: ErrorFormat;

  /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://github.com/prisma/prisma/blob/master/docs/prisma-client-js/api.md).
   */
  constructor(optionsArg?: T);
  on<V extends U>(eventType: V, callback: (event: V extends 'query' ? QueryEvent : LogEvent) => void): void;
  /**
   * Connect with the database
   */
  connect(): Promise<void>;
  /**
   * @private
   */
  private runDisconnect;
  /**
   * Disconnect from the database
   */
  disconnect(): Promise<any>;

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://github.com/prisma/prisma/blob/master/docs/prisma-client-js/api.md#raw-database-access).
  */
  executeRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://github.com/prisma/prisma/blob/master/docs/prisma-client-js/api.md#raw-database-access).
  */
  queryRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<T>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): AccountDelegate;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): UserDelegate;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): EventDelegate;

  /**
   * `prisma.eventParent`: Exposes CRUD operations for the **EventParent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventParents
    * const eventParents = await prisma.eventParent.findMany()
    * ```
    */
  get eventParent(): EventParentDelegate;

  /**
   * `prisma.eventException`: Exposes CRUD operations for the **EventException** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventExceptions
    * const eventExceptions = await prisma.eventException.findMany()
    * ```
    */
  get eventException(): EventExceptionDelegate;

  /**
   * `prisma.eventCancellation`: Exposes CRUD operations for the **EventCancellation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventCancellations
    * const eventCancellations = await prisma.eventCancellation.findMany()
    * ```
    */
  get eventCancellation(): EventCancellationDelegate;

  /**
   * `prisma.filter`: Exposes CRUD operations for the **Filter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Filters
    * const filters = await prisma.filter.findMany()
    * ```
    */
  get filter(): FilterDelegate;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): BookingDelegate;

  /**
   * `prisma.guest`: Exposes CRUD operations for the **Guest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guests
    * const guests = await prisma.guest.findMany()
    * ```
    */
  get guest(): GuestDelegate;

  /**
   * `prisma.cart`: Exposes CRUD operations for the **Cart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carts
    * const carts = await prisma.cart.findMany()
    * ```
    */
  get cart(): CartDelegate;

  /**
   * `prisma.cartBooking`: Exposes CRUD operations for the **CartBooking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CartBookings
    * const cartBookings = await prisma.cartBooking.findMany()
    * ```
    */
  get cartBooking(): CartBookingDelegate;
}



/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export declare const OrderByArg: {
  asc: 'asc',
  desc: 'desc'
};

export declare type OrderByArg = (typeof OrderByArg)[keyof typeof OrderByArg]


export declare const FilterType: {
  HOST: 'HOST',
  TAG: 'TAG',
  LOCATION: 'LOCATION'
};

export declare type FilterType = (typeof FilterType)[keyof typeof FilterType]


export declare const PaymentStatus: {
  PENDING: 'PENDING',
  SUCCESS: 'SUCCESS',
  FAILED: 'FAILED'
};

export declare type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]



/**
 * Model Account
 */

export type Account = {
  id: string
  createdAt: Date
  settings: string
  stripe_accountId: string | null
  stripe_refreshToken: string | null
  stripe_customerId: string | null
  stripe_subscriptionStatus: string | null
  ownerId: string
}

export type AccountSelect = {
  id?: boolean
  createdAt?: boolean
  settings?: boolean
  stripe_accountId?: boolean
  stripe_refreshToken?: boolean
  stripe_customerId?: boolean
  stripe_subscriptionStatus?: boolean
  owner?: boolean | UserArgs
  ownerId?: boolean
  eventParents?: boolean | FindManyEventParentArgs
  filters?: boolean | FindManyFilterArgs
  CartBooking?: boolean | FindManyCartBookingArgs
  Cart?: boolean | FindManyCartArgs
}

export type AccountInclude = {
  owner?: boolean | UserArgs
  eventParents?: boolean | FindManyEventParentArgs
  filters?: boolean | FindManyFilterArgs
  CartBooking?: boolean | FindManyCartBookingArgs
  Cart?: boolean | FindManyCartArgs
}

export type AccountGetPayload<
  S extends boolean | null | undefined | AccountArgs,
  U = keyof S
> = S extends true
  ? Account
  : S extends undefined
  ? never
  : S extends AccountArgs | FindManyAccountArgs
  ? 'include' extends U
    ? Account  & {
      [P in TrueKeys<S['include']>]:
      P extends 'owner'
      ? UserGetPayload<S['include'][P]> :
      P extends 'eventParents'
      ? Array<EventParentGetPayload<S['include'][P]>> :
      P extends 'filters'
      ? Array<FilterGetPayload<S['include'][P]>> :
      P extends 'CartBooking'
      ? Array<CartBookingGetPayload<S['include'][P]>> :
      P extends 'Cart'
      ? Array<CartGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Account ? Account[P]
: 
      P extends 'owner'
      ? UserGetPayload<S['select'][P]> :
      P extends 'eventParents'
      ? Array<EventParentGetPayload<S['select'][P]>> :
      P extends 'filters'
      ? Array<FilterGetPayload<S['select'][P]>> :
      P extends 'CartBooking'
      ? Array<CartBookingGetPayload<S['select'][P]>> :
      P extends 'Cart'
      ? Array<CartGetPayload<S['select'][P]>> : never
    }
  : Account
: Account


export interface AccountDelegate {
  /**
   * Find zero or one Account.
   * @param {FindOneAccountArgs} args - Arguments to find a Account
   * @example
   * // Get one Account
   * const account = await prisma.account.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneAccountArgs>(
    args: Subset<T, FindOneAccountArgs>
  ): CheckSelect<T, AccountClient<Account | null>, AccountClient<AccountGetPayload<T> | null>>
  /**
   * Find zero or more Accounts.
   * @param {FindManyAccountArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Accounts
   * const accounts = await prisma.account.findMany()
   * 
   * // Get first 10 Accounts
   * const accounts = await prisma.account.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyAccountArgs>(
    args?: Subset<T, FindManyAccountArgs>
  ): CheckSelect<T, Promise<Array<Account>>, Promise<Array<AccountGetPayload<T>>>>
  /**
   * Create a Account.
   * @param {AccountCreateArgs} args - Arguments to create a Account.
   * @example
   * // Create one Account
   * const user = await prisma.account.create({
   *   data: {
   *     // ... data to create a Account
   *   }
   * })
   * 
  **/
  create<T extends AccountCreateArgs>(
    args: Subset<T, AccountCreateArgs>
  ): CheckSelect<T, AccountClient<Account>, AccountClient<AccountGetPayload<T>>>
  /**
   * Delete a Account.
   * @param {AccountDeleteArgs} args - Arguments to delete one Account.
   * @example
   * // Delete one Account
   * const user = await prisma.account.delete({
   *   where: {
   *     // ... filter to delete one Account
   *   }
   * })
   * 
  **/
  delete<T extends AccountDeleteArgs>(
    args: Subset<T, AccountDeleteArgs>
  ): CheckSelect<T, AccountClient<Account>, AccountClient<AccountGetPayload<T>>>
  /**
   * Update one Account.
   * @param {AccountUpdateArgs} args - Arguments to update one Account.
   * @example
   * // Update one Account
   * const account = await prisma.account.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends AccountUpdateArgs>(
    args: Subset<T, AccountUpdateArgs>
  ): CheckSelect<T, AccountClient<Account>, AccountClient<AccountGetPayload<T>>>
  /**
   * Delete zero or more Accounts.
   * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
   * @example
   * // Delete a few Accounts
   * const { count } = await prisma.account.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends AccountDeleteManyArgs>(
    args: Subset<T, AccountDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Accounts.
   * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Accounts
   * const account = await prisma.account.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends AccountUpdateManyArgs>(
    args: Subset<T, AccountUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Account.
   * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
   * @example
   * // Update or create a Account
   * const account = await prisma.account.upsert({
   *   create: {
   *     // ... data to create a Account
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Account we want to update
   *   }
   * })
  **/
  upsert<T extends AccountUpsertArgs>(
    args: Subset<T, AccountUpsertArgs>
  ): CheckSelect<T, AccountClient<Account>, AccountClient<AccountGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManyAccountArgs, 'select' | 'include'>): Promise<number>
}

export declare class AccountClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  owner<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, UserClient<User | null>, UserClient<UserGetPayload<T> | null>>;

  eventParents<T extends FindManyEventParentArgs = {}>(args?: Subset<T, FindManyEventParentArgs>): CheckSelect<T, Promise<Array<EventParent>>, Promise<Array<EventParentGetPayload<T>>>>;

  filters<T extends FindManyFilterArgs = {}>(args?: Subset<T, FindManyFilterArgs>): CheckSelect<T, Promise<Array<Filter>>, Promise<Array<FilterGetPayload<T>>>>;

  CartBooking<T extends FindManyCartBookingArgs = {}>(args?: Subset<T, FindManyCartBookingArgs>): CheckSelect<T, Promise<Array<CartBooking>>, Promise<Array<CartBookingGetPayload<T>>>>;

  Cart<T extends FindManyCartArgs = {}>(args?: Subset<T, FindManyCartArgs>): CheckSelect<T, Promise<Array<Cart>>, Promise<Array<CartGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Account findOne
 */
export type FindOneAccountArgs = {
  /**
   * Select specific fields to fetch from the Account
  **/
  select?: AccountSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AccountInclude | null
  /**
   * Filter, which Account to fetch.
  **/
  where: AccountWhereUniqueInput
}


/**
 * Account findMany
 */
export type FindManyAccountArgs = {
  /**
   * Select specific fields to fetch from the Account
  **/
  select?: AccountSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AccountInclude | null
  /**
   * Filter, which Accounts to fetch.
  **/
  where?: AccountWhereInput
  /**
   * Determine the order of the Accounts to fetch.
  **/
  orderBy?: AccountOrderByInput
  /**
   * Sets the position for listing Accounts.
  **/
  cursor?: AccountWhereUniqueInput
  /**
   * The number of Accounts to fetch. If negative number, it will take Accounts before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Accounts.
  **/
  skip?: number
}


/**
 * Account create
 */
export type AccountCreateArgs = {
  /**
   * Select specific fields to fetch from the Account
  **/
  select?: AccountSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AccountInclude | null
  /**
   * The data needed to create a Account.
  **/
  data: AccountCreateInput
}


/**
 * Account update
 */
export type AccountUpdateArgs = {
  /**
   * Select specific fields to fetch from the Account
  **/
  select?: AccountSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AccountInclude | null
  /**
   * The data needed to update a Account.
  **/
  data: AccountUpdateInput
  /**
   * Choose, which Account to update.
  **/
  where: AccountWhereUniqueInput
}


/**
 * Account updateMany
 */
export type AccountUpdateManyArgs = {
  data: AccountUpdateManyMutationInput
  where?: AccountWhereInput
}


/**
 * Account upsert
 */
export type AccountUpsertArgs = {
  /**
   * Select specific fields to fetch from the Account
  **/
  select?: AccountSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AccountInclude | null
  /**
   * The filter to search for the Account to update in case it exists.
  **/
  where: AccountWhereUniqueInput
  /**
   * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
  **/
  create: AccountCreateInput
  /**
   * In case the Account was found with the provided `where` argument, update it with this data.
  **/
  update: AccountUpdateInput
}


/**
 * Account delete
 */
export type AccountDeleteArgs = {
  /**
   * Select specific fields to fetch from the Account
  **/
  select?: AccountSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AccountInclude | null
  /**
   * Filter which Account to delete.
  **/
  where: AccountWhereUniqueInput
}


/**
 * Account deleteMany
 */
export type AccountDeleteManyArgs = {
  where?: AccountWhereInput
}


/**
 * Account without action
 */
export type AccountArgs = {
  /**
   * Select specific fields to fetch from the Account
  **/
  select?: AccountSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AccountInclude | null
}



/**
 * Model User
 */

export type User = {
  id: string
  createdAt: Date
  auth0_userId: string
  isGuest: boolean | null
}

export type UserSelect = {
  id?: boolean
  createdAt?: boolean
  auth0_userId?: boolean
  isGuest?: boolean
  bookings?: boolean | FindManyBookingArgs
  account?: boolean | AccountArgs
  eventParents?: boolean | FindManyEventParentArgs
  Cart?: boolean | FindManyCartArgs
}

export type UserInclude = {
  bookings?: boolean | FindManyBookingArgs
  account?: boolean | AccountArgs
  eventParents?: boolean | FindManyEventParentArgs
  Cart?: boolean | FindManyCartArgs
}

export type UserGetPayload<
  S extends boolean | null | undefined | UserArgs,
  U = keyof S
> = S extends true
  ? User
  : S extends undefined
  ? never
  : S extends UserArgs | FindManyUserArgs
  ? 'include' extends U
    ? User  & {
      [P in TrueKeys<S['include']>]:
      P extends 'bookings'
      ? Array<BookingGetPayload<S['include'][P]>> :
      P extends 'account'
      ? AccountGetPayload<S['include'][P]> | null :
      P extends 'eventParents'
      ? Array<EventParentGetPayload<S['include'][P]>> :
      P extends 'Cart'
      ? Array<CartGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof User ? User[P]
: 
      P extends 'bookings'
      ? Array<BookingGetPayload<S['select'][P]>> :
      P extends 'account'
      ? AccountGetPayload<S['select'][P]> | null :
      P extends 'eventParents'
      ? Array<EventParentGetPayload<S['select'][P]>> :
      P extends 'Cart'
      ? Array<CartGetPayload<S['select'][P]>> : never
    }
  : User
: User


export interface UserDelegate {
  /**
   * Find zero or one User.
   * @param {FindOneUserArgs} args - Arguments to find a User
   * @example
   * // Get one User
   * const user = await prisma.user.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneUserArgs>(
    args: Subset<T, FindOneUserArgs>
  ): CheckSelect<T, UserClient<User | null>, UserClient<UserGetPayload<T> | null>>
  /**
   * Find zero or more Users.
   * @param {FindManyUserArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Users
   * const users = await prisma.user.findMany()
   * 
   * // Get first 10 Users
   * const users = await prisma.user.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyUserArgs>(
    args?: Subset<T, FindManyUserArgs>
  ): CheckSelect<T, Promise<Array<User>>, Promise<Array<UserGetPayload<T>>>>
  /**
   * Create a User.
   * @param {UserCreateArgs} args - Arguments to create a User.
   * @example
   * // Create one User
   * const user = await prisma.user.create({
   *   data: {
   *     // ... data to create a User
   *   }
   * })
   * 
  **/
  create<T extends UserCreateArgs>(
    args: Subset<T, UserCreateArgs>
  ): CheckSelect<T, UserClient<User>, UserClient<UserGetPayload<T>>>
  /**
   * Delete a User.
   * @param {UserDeleteArgs} args - Arguments to delete one User.
   * @example
   * // Delete one User
   * const user = await prisma.user.delete({
   *   where: {
   *     // ... filter to delete one User
   *   }
   * })
   * 
  **/
  delete<T extends UserDeleteArgs>(
    args: Subset<T, UserDeleteArgs>
  ): CheckSelect<T, UserClient<User>, UserClient<UserGetPayload<T>>>
  /**
   * Update one User.
   * @param {UserUpdateArgs} args - Arguments to update one User.
   * @example
   * // Update one User
   * const user = await prisma.user.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends UserUpdateArgs>(
    args: Subset<T, UserUpdateArgs>
  ): CheckSelect<T, UserClient<User>, UserClient<UserGetPayload<T>>>
  /**
   * Delete zero or more Users.
   * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
   * @example
   * // Delete a few Users
   * const { count } = await prisma.user.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends UserDeleteManyArgs>(
    args: Subset<T, UserDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Users.
   * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Users
   * const user = await prisma.user.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends UserUpdateManyArgs>(
    args: Subset<T, UserUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one User.
   * @param {UserUpsertArgs} args - Arguments to update or create a User.
   * @example
   * // Update or create a User
   * const user = await prisma.user.upsert({
   *   create: {
   *     // ... data to create a User
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the User we want to update
   *   }
   * })
  **/
  upsert<T extends UserUpsertArgs>(
    args: Subset<T, UserUpsertArgs>
  ): CheckSelect<T, UserClient<User>, UserClient<UserGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManyUserArgs, 'select' | 'include'>): Promise<number>
}

export declare class UserClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  bookings<T extends FindManyBookingArgs = {}>(args?: Subset<T, FindManyBookingArgs>): CheckSelect<T, Promise<Array<Booking>>, Promise<Array<BookingGetPayload<T>>>>;

  account<T extends AccountArgs = {}>(args?: Subset<T, AccountArgs>): CheckSelect<T, AccountClient<Account | null>, AccountClient<AccountGetPayload<T> | null>>;

  eventParents<T extends FindManyEventParentArgs = {}>(args?: Subset<T, FindManyEventParentArgs>): CheckSelect<T, Promise<Array<EventParent>>, Promise<Array<EventParentGetPayload<T>>>>;

  Cart<T extends FindManyCartArgs = {}>(args?: Subset<T, FindManyCartArgs>): CheckSelect<T, Promise<Array<Cart>>, Promise<Array<CartGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * User findOne
 */
export type FindOneUserArgs = {
  /**
   * Select specific fields to fetch from the User
  **/
  select?: UserSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UserInclude | null
  /**
   * Filter, which User to fetch.
  **/
  where: UserWhereUniqueInput
}


/**
 * User findMany
 */
export type FindManyUserArgs = {
  /**
   * Select specific fields to fetch from the User
  **/
  select?: UserSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UserInclude | null
  /**
   * Filter, which Users to fetch.
  **/
  where?: UserWhereInput
  /**
   * Determine the order of the Users to fetch.
  **/
  orderBy?: UserOrderByInput
  /**
   * Sets the position for listing Users.
  **/
  cursor?: UserWhereUniqueInput
  /**
   * The number of Users to fetch. If negative number, it will take Users before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Users.
  **/
  skip?: number
}


/**
 * User create
 */
export type UserCreateArgs = {
  /**
   * Select specific fields to fetch from the User
  **/
  select?: UserSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UserInclude | null
  /**
   * The data needed to create a User.
  **/
  data: UserCreateInput
}


/**
 * User update
 */
export type UserUpdateArgs = {
  /**
   * Select specific fields to fetch from the User
  **/
  select?: UserSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UserInclude | null
  /**
   * The data needed to update a User.
  **/
  data: UserUpdateInput
  /**
   * Choose, which User to update.
  **/
  where: UserWhereUniqueInput
}


/**
 * User updateMany
 */
export type UserUpdateManyArgs = {
  data: UserUpdateManyMutationInput
  where?: UserWhereInput
}


/**
 * User upsert
 */
export type UserUpsertArgs = {
  /**
   * Select specific fields to fetch from the User
  **/
  select?: UserSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UserInclude | null
  /**
   * The filter to search for the User to update in case it exists.
  **/
  where: UserWhereUniqueInput
  /**
   * In case the User found by the `where` argument doesn't exist, create a new User with this data.
  **/
  create: UserCreateInput
  /**
   * In case the User was found with the provided `where` argument, update it with this data.
  **/
  update: UserUpdateInput
}


/**
 * User delete
 */
export type UserDeleteArgs = {
  /**
   * Select specific fields to fetch from the User
  **/
  select?: UserSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UserInclude | null
  /**
   * Filter which User to delete.
  **/
  where: UserWhereUniqueInput
}


/**
 * User deleteMany
 */
export type UserDeleteManyArgs = {
  where?: UserWhereInput
}


/**
 * User without action
 */
export type UserArgs = {
  /**
   * Select specific fields to fetch from the User
  **/
  select?: UserSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UserInclude | null
}



/**
 * Model Event
 */

export type Event = {
  id: string
  createdAt: Date
  title: string
  description: string
  price: number
  spaces: number
  duration: number
}

export type EventSelect = {
  id?: boolean
  createdAt?: boolean
  title?: boolean
  description?: boolean
  price?: boolean
  spaces?: boolean
  duration?: boolean
  filters?: boolean | FindManyFilterArgs
  eventParents?: boolean | FindManyEventParentArgs
  eventExceptions?: boolean | FindManyEventExceptionArgs
}

export type EventInclude = {
  filters?: boolean | FindManyFilterArgs
  eventParents?: boolean | FindManyEventParentArgs
  eventExceptions?: boolean | FindManyEventExceptionArgs
}

export type EventGetPayload<
  S extends boolean | null | undefined | EventArgs,
  U = keyof S
> = S extends true
  ? Event
  : S extends undefined
  ? never
  : S extends EventArgs | FindManyEventArgs
  ? 'include' extends U
    ? Event  & {
      [P in TrueKeys<S['include']>]:
      P extends 'filters'
      ? Array<FilterGetPayload<S['include'][P]>> :
      P extends 'eventParents'
      ? Array<EventParentGetPayload<S['include'][P]>> :
      P extends 'eventExceptions'
      ? Array<EventExceptionGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Event ? Event[P]
: 
      P extends 'filters'
      ? Array<FilterGetPayload<S['select'][P]>> :
      P extends 'eventParents'
      ? Array<EventParentGetPayload<S['select'][P]>> :
      P extends 'eventExceptions'
      ? Array<EventExceptionGetPayload<S['select'][P]>> : never
    }
  : Event
: Event


export interface EventDelegate {
  /**
   * Find zero or one Event.
   * @param {FindOneEventArgs} args - Arguments to find a Event
   * @example
   * // Get one Event
   * const event = await prisma.event.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneEventArgs>(
    args: Subset<T, FindOneEventArgs>
  ): CheckSelect<T, EventClient<Event | null>, EventClient<EventGetPayload<T> | null>>
  /**
   * Find zero or more Events.
   * @param {FindManyEventArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Events
   * const events = await prisma.event.findMany()
   * 
   * // Get first 10 Events
   * const events = await prisma.event.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyEventArgs>(
    args?: Subset<T, FindManyEventArgs>
  ): CheckSelect<T, Promise<Array<Event>>, Promise<Array<EventGetPayload<T>>>>
  /**
   * Create a Event.
   * @param {EventCreateArgs} args - Arguments to create a Event.
   * @example
   * // Create one Event
   * const user = await prisma.event.create({
   *   data: {
   *     // ... data to create a Event
   *   }
   * })
   * 
  **/
  create<T extends EventCreateArgs>(
    args: Subset<T, EventCreateArgs>
  ): CheckSelect<T, EventClient<Event>, EventClient<EventGetPayload<T>>>
  /**
   * Delete a Event.
   * @param {EventDeleteArgs} args - Arguments to delete one Event.
   * @example
   * // Delete one Event
   * const user = await prisma.event.delete({
   *   where: {
   *     // ... filter to delete one Event
   *   }
   * })
   * 
  **/
  delete<T extends EventDeleteArgs>(
    args: Subset<T, EventDeleteArgs>
  ): CheckSelect<T, EventClient<Event>, EventClient<EventGetPayload<T>>>
  /**
   * Update one Event.
   * @param {EventUpdateArgs} args - Arguments to update one Event.
   * @example
   * // Update one Event
   * const event = await prisma.event.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends EventUpdateArgs>(
    args: Subset<T, EventUpdateArgs>
  ): CheckSelect<T, EventClient<Event>, EventClient<EventGetPayload<T>>>
  /**
   * Delete zero or more Events.
   * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
   * @example
   * // Delete a few Events
   * const { count } = await prisma.event.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends EventDeleteManyArgs>(
    args: Subset<T, EventDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Events.
   * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Events
   * const event = await prisma.event.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends EventUpdateManyArgs>(
    args: Subset<T, EventUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Event.
   * @param {EventUpsertArgs} args - Arguments to update or create a Event.
   * @example
   * // Update or create a Event
   * const event = await prisma.event.upsert({
   *   create: {
   *     // ... data to create a Event
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Event we want to update
   *   }
   * })
  **/
  upsert<T extends EventUpsertArgs>(
    args: Subset<T, EventUpsertArgs>
  ): CheckSelect<T, EventClient<Event>, EventClient<EventGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManyEventArgs, 'select' | 'include'>): Promise<number>
}

export declare class EventClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  filters<T extends FindManyFilterArgs = {}>(args?: Subset<T, FindManyFilterArgs>): CheckSelect<T, Promise<Array<Filter>>, Promise<Array<FilterGetPayload<T>>>>;

  eventParents<T extends FindManyEventParentArgs = {}>(args?: Subset<T, FindManyEventParentArgs>): CheckSelect<T, Promise<Array<EventParent>>, Promise<Array<EventParentGetPayload<T>>>>;

  eventExceptions<T extends FindManyEventExceptionArgs = {}>(args?: Subset<T, FindManyEventExceptionArgs>): CheckSelect<T, Promise<Array<EventException>>, Promise<Array<EventExceptionGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Event findOne
 */
export type FindOneEventArgs = {
  /**
   * Select specific fields to fetch from the Event
  **/
  select?: EventSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventInclude | null
  /**
   * Filter, which Event to fetch.
  **/
  where: EventWhereUniqueInput
}


/**
 * Event findMany
 */
export type FindManyEventArgs = {
  /**
   * Select specific fields to fetch from the Event
  **/
  select?: EventSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventInclude | null
  /**
   * Filter, which Events to fetch.
  **/
  where?: EventWhereInput
  /**
   * Determine the order of the Events to fetch.
  **/
  orderBy?: EventOrderByInput
  /**
   * Sets the position for listing Events.
  **/
  cursor?: EventWhereUniqueInput
  /**
   * The number of Events to fetch. If negative number, it will take Events before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Events.
  **/
  skip?: number
}


/**
 * Event create
 */
export type EventCreateArgs = {
  /**
   * Select specific fields to fetch from the Event
  **/
  select?: EventSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventInclude | null
  /**
   * The data needed to create a Event.
  **/
  data: EventCreateInput
}


/**
 * Event update
 */
export type EventUpdateArgs = {
  /**
   * Select specific fields to fetch from the Event
  **/
  select?: EventSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventInclude | null
  /**
   * The data needed to update a Event.
  **/
  data: EventUpdateInput
  /**
   * Choose, which Event to update.
  **/
  where: EventWhereUniqueInput
}


/**
 * Event updateMany
 */
export type EventUpdateManyArgs = {
  data: EventUpdateManyMutationInput
  where?: EventWhereInput
}


/**
 * Event upsert
 */
export type EventUpsertArgs = {
  /**
   * Select specific fields to fetch from the Event
  **/
  select?: EventSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventInclude | null
  /**
   * The filter to search for the Event to update in case it exists.
  **/
  where: EventWhereUniqueInput
  /**
   * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
  **/
  create: EventCreateInput
  /**
   * In case the Event was found with the provided `where` argument, update it with this data.
  **/
  update: EventUpdateInput
}


/**
 * Event delete
 */
export type EventDeleteArgs = {
  /**
   * Select specific fields to fetch from the Event
  **/
  select?: EventSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventInclude | null
  /**
   * Filter which Event to delete.
  **/
  where: EventWhereUniqueInput
}


/**
 * Event deleteMany
 */
export type EventDeleteManyArgs = {
  where?: EventWhereInput
}


/**
 * Event without action
 */
export type EventArgs = {
  /**
   * Select specific fields to fetch from the Event
  **/
  select?: EventSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventInclude | null
}



/**
 * Model EventParent
 */

export type EventParent = {
  id: string
  createdAt: Date
  deletedAt: Date | null
  isPublished: boolean
  rule: string
  createdByUserId: string
  accountId: string
  eventId: string
}

export type EventParentSelect = {
  id?: boolean
  createdAt?: boolean
  deletedAt?: boolean
  isPublished?: boolean
  rule?: boolean
  createdBy?: boolean | UserArgs
  createdByUserId?: boolean
  account?: boolean | AccountArgs
  accountId?: boolean
  exceptions?: boolean | FindManyEventExceptionArgs
  cancellations?: boolean | FindManyEventCancellationArgs
  event?: boolean | EventArgs
  eventId?: boolean
}

export type EventParentInclude = {
  createdBy?: boolean | UserArgs
  account?: boolean | AccountArgs
  exceptions?: boolean | FindManyEventExceptionArgs
  cancellations?: boolean | FindManyEventCancellationArgs
  event?: boolean | EventArgs
}

export type EventParentGetPayload<
  S extends boolean | null | undefined | EventParentArgs,
  U = keyof S
> = S extends true
  ? EventParent
  : S extends undefined
  ? never
  : S extends EventParentArgs | FindManyEventParentArgs
  ? 'include' extends U
    ? EventParent  & {
      [P in TrueKeys<S['include']>]:
      P extends 'createdBy'
      ? UserGetPayload<S['include'][P]> :
      P extends 'account'
      ? AccountGetPayload<S['include'][P]> :
      P extends 'exceptions'
      ? Array<EventExceptionGetPayload<S['include'][P]>> :
      P extends 'cancellations'
      ? Array<EventCancellationGetPayload<S['include'][P]>> :
      P extends 'event'
      ? EventGetPayload<S['include'][P]> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof EventParent ? EventParent[P]
: 
      P extends 'createdBy'
      ? UserGetPayload<S['select'][P]> :
      P extends 'account'
      ? AccountGetPayload<S['select'][P]> :
      P extends 'exceptions'
      ? Array<EventExceptionGetPayload<S['select'][P]>> :
      P extends 'cancellations'
      ? Array<EventCancellationGetPayload<S['select'][P]>> :
      P extends 'event'
      ? EventGetPayload<S['select'][P]> : never
    }
  : EventParent
: EventParent


export interface EventParentDelegate {
  /**
   * Find zero or one EventParent.
   * @param {FindOneEventParentArgs} args - Arguments to find a EventParent
   * @example
   * // Get one EventParent
   * const eventParent = await prisma.eventParent.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneEventParentArgs>(
    args: Subset<T, FindOneEventParentArgs>
  ): CheckSelect<T, EventParentClient<EventParent | null>, EventParentClient<EventParentGetPayload<T> | null>>
  /**
   * Find zero or more EventParents.
   * @param {FindManyEventParentArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all EventParents
   * const eventParents = await prisma.eventParent.findMany()
   * 
   * // Get first 10 EventParents
   * const eventParents = await prisma.eventParent.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const eventParentWithIdOnly = await prisma.eventParent.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyEventParentArgs>(
    args?: Subset<T, FindManyEventParentArgs>
  ): CheckSelect<T, Promise<Array<EventParent>>, Promise<Array<EventParentGetPayload<T>>>>
  /**
   * Create a EventParent.
   * @param {EventParentCreateArgs} args - Arguments to create a EventParent.
   * @example
   * // Create one EventParent
   * const user = await prisma.eventParent.create({
   *   data: {
   *     // ... data to create a EventParent
   *   }
   * })
   * 
  **/
  create<T extends EventParentCreateArgs>(
    args: Subset<T, EventParentCreateArgs>
  ): CheckSelect<T, EventParentClient<EventParent>, EventParentClient<EventParentGetPayload<T>>>
  /**
   * Delete a EventParent.
   * @param {EventParentDeleteArgs} args - Arguments to delete one EventParent.
   * @example
   * // Delete one EventParent
   * const user = await prisma.eventParent.delete({
   *   where: {
   *     // ... filter to delete one EventParent
   *   }
   * })
   * 
  **/
  delete<T extends EventParentDeleteArgs>(
    args: Subset<T, EventParentDeleteArgs>
  ): CheckSelect<T, EventParentClient<EventParent>, EventParentClient<EventParentGetPayload<T>>>
  /**
   * Update one EventParent.
   * @param {EventParentUpdateArgs} args - Arguments to update one EventParent.
   * @example
   * // Update one EventParent
   * const eventParent = await prisma.eventParent.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends EventParentUpdateArgs>(
    args: Subset<T, EventParentUpdateArgs>
  ): CheckSelect<T, EventParentClient<EventParent>, EventParentClient<EventParentGetPayload<T>>>
  /**
   * Delete zero or more EventParents.
   * @param {EventParentDeleteManyArgs} args - Arguments to filter EventParents to delete.
   * @example
   * // Delete a few EventParents
   * const { count } = await prisma.eventParent.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends EventParentDeleteManyArgs>(
    args: Subset<T, EventParentDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more EventParents.
   * @param {EventParentUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many EventParents
   * const eventParent = await prisma.eventParent.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends EventParentUpdateManyArgs>(
    args: Subset<T, EventParentUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one EventParent.
   * @param {EventParentUpsertArgs} args - Arguments to update or create a EventParent.
   * @example
   * // Update or create a EventParent
   * const eventParent = await prisma.eventParent.upsert({
   *   create: {
   *     // ... data to create a EventParent
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the EventParent we want to update
   *   }
   * })
  **/
  upsert<T extends EventParentUpsertArgs>(
    args: Subset<T, EventParentUpsertArgs>
  ): CheckSelect<T, EventParentClient<EventParent>, EventParentClient<EventParentGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManyEventParentArgs, 'select' | 'include'>): Promise<number>
}

export declare class EventParentClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  createdBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, UserClient<User | null>, UserClient<UserGetPayload<T> | null>>;

  account<T extends AccountArgs = {}>(args?: Subset<T, AccountArgs>): CheckSelect<T, AccountClient<Account | null>, AccountClient<AccountGetPayload<T> | null>>;

  exceptions<T extends FindManyEventExceptionArgs = {}>(args?: Subset<T, FindManyEventExceptionArgs>): CheckSelect<T, Promise<Array<EventException>>, Promise<Array<EventExceptionGetPayload<T>>>>;

  cancellations<T extends FindManyEventCancellationArgs = {}>(args?: Subset<T, FindManyEventCancellationArgs>): CheckSelect<T, Promise<Array<EventCancellation>>, Promise<Array<EventCancellationGetPayload<T>>>>;

  event<T extends EventArgs = {}>(args?: Subset<T, EventArgs>): CheckSelect<T, EventClient<Event | null>, EventClient<EventGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * EventParent findOne
 */
export type FindOneEventParentArgs = {
  /**
   * Select specific fields to fetch from the EventParent
  **/
  select?: EventParentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventParentInclude | null
  /**
   * Filter, which EventParent to fetch.
  **/
  where: EventParentWhereUniqueInput
}


/**
 * EventParent findMany
 */
export type FindManyEventParentArgs = {
  /**
   * Select specific fields to fetch from the EventParent
  **/
  select?: EventParentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventParentInclude | null
  /**
   * Filter, which EventParents to fetch.
  **/
  where?: EventParentWhereInput
  /**
   * Determine the order of the EventParents to fetch.
  **/
  orderBy?: EventParentOrderByInput
  /**
   * Sets the position for listing EventParents.
  **/
  cursor?: EventParentWhereUniqueInput
  /**
   * The number of EventParents to fetch. If negative number, it will take EventParents before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` EventParents.
  **/
  skip?: number
}


/**
 * EventParent create
 */
export type EventParentCreateArgs = {
  /**
   * Select specific fields to fetch from the EventParent
  **/
  select?: EventParentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventParentInclude | null
  /**
   * The data needed to create a EventParent.
  **/
  data: EventParentCreateInput
}


/**
 * EventParent update
 */
export type EventParentUpdateArgs = {
  /**
   * Select specific fields to fetch from the EventParent
  **/
  select?: EventParentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventParentInclude | null
  /**
   * The data needed to update a EventParent.
  **/
  data: EventParentUpdateInput
  /**
   * Choose, which EventParent to update.
  **/
  where: EventParentWhereUniqueInput
}


/**
 * EventParent updateMany
 */
export type EventParentUpdateManyArgs = {
  data: EventParentUpdateManyMutationInput
  where?: EventParentWhereInput
}


/**
 * EventParent upsert
 */
export type EventParentUpsertArgs = {
  /**
   * Select specific fields to fetch from the EventParent
  **/
  select?: EventParentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventParentInclude | null
  /**
   * The filter to search for the EventParent to update in case it exists.
  **/
  where: EventParentWhereUniqueInput
  /**
   * In case the EventParent found by the `where` argument doesn't exist, create a new EventParent with this data.
  **/
  create: EventParentCreateInput
  /**
   * In case the EventParent was found with the provided `where` argument, update it with this data.
  **/
  update: EventParentUpdateInput
}


/**
 * EventParent delete
 */
export type EventParentDeleteArgs = {
  /**
   * Select specific fields to fetch from the EventParent
  **/
  select?: EventParentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventParentInclude | null
  /**
   * Filter which EventParent to delete.
  **/
  where: EventParentWhereUniqueInput
}


/**
 * EventParent deleteMany
 */
export type EventParentDeleteManyArgs = {
  where?: EventParentWhereInput
}


/**
 * EventParent without action
 */
export type EventParentArgs = {
  /**
   * Select specific fields to fetch from the EventParent
  **/
  select?: EventParentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventParentInclude | null
}



/**
 * Model EventException
 */

export type EventException = {
  id: string
  createdAt: Date
  originalDate: Date
  date: Date
  cancelled: boolean
  parentId: string
  eventId: string
}

export type EventExceptionSelect = {
  id?: boolean
  createdAt?: boolean
  originalDate?: boolean
  date?: boolean
  cancelled?: boolean
  bookings?: boolean | FindManyBookingArgs
  parent?: boolean | EventParentArgs
  parentId?: boolean
  event?: boolean | EventArgs
  eventId?: boolean
}

export type EventExceptionInclude = {
  bookings?: boolean | FindManyBookingArgs
  parent?: boolean | EventParentArgs
  event?: boolean | EventArgs
}

export type EventExceptionGetPayload<
  S extends boolean | null | undefined | EventExceptionArgs,
  U = keyof S
> = S extends true
  ? EventException
  : S extends undefined
  ? never
  : S extends EventExceptionArgs | FindManyEventExceptionArgs
  ? 'include' extends U
    ? EventException  & {
      [P in TrueKeys<S['include']>]:
      P extends 'bookings'
      ? Array<BookingGetPayload<S['include'][P]>> :
      P extends 'parent'
      ? EventParentGetPayload<S['include'][P]> :
      P extends 'event'
      ? EventGetPayload<S['include'][P]> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof EventException ? EventException[P]
: 
      P extends 'bookings'
      ? Array<BookingGetPayload<S['select'][P]>> :
      P extends 'parent'
      ? EventParentGetPayload<S['select'][P]> :
      P extends 'event'
      ? EventGetPayload<S['select'][P]> : never
    }
  : EventException
: EventException


export interface EventExceptionDelegate {
  /**
   * Find zero or one EventException.
   * @param {FindOneEventExceptionArgs} args - Arguments to find a EventException
   * @example
   * // Get one EventException
   * const eventException = await prisma.eventException.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneEventExceptionArgs>(
    args: Subset<T, FindOneEventExceptionArgs>
  ): CheckSelect<T, EventExceptionClient<EventException | null>, EventExceptionClient<EventExceptionGetPayload<T> | null>>
  /**
   * Find zero or more EventExceptions.
   * @param {FindManyEventExceptionArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all EventExceptions
   * const eventExceptions = await prisma.eventException.findMany()
   * 
   * // Get first 10 EventExceptions
   * const eventExceptions = await prisma.eventException.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const eventExceptionWithIdOnly = await prisma.eventException.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyEventExceptionArgs>(
    args?: Subset<T, FindManyEventExceptionArgs>
  ): CheckSelect<T, Promise<Array<EventException>>, Promise<Array<EventExceptionGetPayload<T>>>>
  /**
   * Create a EventException.
   * @param {EventExceptionCreateArgs} args - Arguments to create a EventException.
   * @example
   * // Create one EventException
   * const user = await prisma.eventException.create({
   *   data: {
   *     // ... data to create a EventException
   *   }
   * })
   * 
  **/
  create<T extends EventExceptionCreateArgs>(
    args: Subset<T, EventExceptionCreateArgs>
  ): CheckSelect<T, EventExceptionClient<EventException>, EventExceptionClient<EventExceptionGetPayload<T>>>
  /**
   * Delete a EventException.
   * @param {EventExceptionDeleteArgs} args - Arguments to delete one EventException.
   * @example
   * // Delete one EventException
   * const user = await prisma.eventException.delete({
   *   where: {
   *     // ... filter to delete one EventException
   *   }
   * })
   * 
  **/
  delete<T extends EventExceptionDeleteArgs>(
    args: Subset<T, EventExceptionDeleteArgs>
  ): CheckSelect<T, EventExceptionClient<EventException>, EventExceptionClient<EventExceptionGetPayload<T>>>
  /**
   * Update one EventException.
   * @param {EventExceptionUpdateArgs} args - Arguments to update one EventException.
   * @example
   * // Update one EventException
   * const eventException = await prisma.eventException.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends EventExceptionUpdateArgs>(
    args: Subset<T, EventExceptionUpdateArgs>
  ): CheckSelect<T, EventExceptionClient<EventException>, EventExceptionClient<EventExceptionGetPayload<T>>>
  /**
   * Delete zero or more EventExceptions.
   * @param {EventExceptionDeleteManyArgs} args - Arguments to filter EventExceptions to delete.
   * @example
   * // Delete a few EventExceptions
   * const { count } = await prisma.eventException.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends EventExceptionDeleteManyArgs>(
    args: Subset<T, EventExceptionDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more EventExceptions.
   * @param {EventExceptionUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many EventExceptions
   * const eventException = await prisma.eventException.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends EventExceptionUpdateManyArgs>(
    args: Subset<T, EventExceptionUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one EventException.
   * @param {EventExceptionUpsertArgs} args - Arguments to update or create a EventException.
   * @example
   * // Update or create a EventException
   * const eventException = await prisma.eventException.upsert({
   *   create: {
   *     // ... data to create a EventException
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the EventException we want to update
   *   }
   * })
  **/
  upsert<T extends EventExceptionUpsertArgs>(
    args: Subset<T, EventExceptionUpsertArgs>
  ): CheckSelect<T, EventExceptionClient<EventException>, EventExceptionClient<EventExceptionGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManyEventExceptionArgs, 'select' | 'include'>): Promise<number>
}

export declare class EventExceptionClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  bookings<T extends FindManyBookingArgs = {}>(args?: Subset<T, FindManyBookingArgs>): CheckSelect<T, Promise<Array<Booking>>, Promise<Array<BookingGetPayload<T>>>>;

  parent<T extends EventParentArgs = {}>(args?: Subset<T, EventParentArgs>): CheckSelect<T, EventParentClient<EventParent | null>, EventParentClient<EventParentGetPayload<T> | null>>;

  event<T extends EventArgs = {}>(args?: Subset<T, EventArgs>): CheckSelect<T, EventClient<Event | null>, EventClient<EventGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * EventException findOne
 */
export type FindOneEventExceptionArgs = {
  /**
   * Select specific fields to fetch from the EventException
  **/
  select?: EventExceptionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventExceptionInclude | null
  /**
   * Filter, which EventException to fetch.
  **/
  where: EventExceptionWhereUniqueInput
}


/**
 * EventException findMany
 */
export type FindManyEventExceptionArgs = {
  /**
   * Select specific fields to fetch from the EventException
  **/
  select?: EventExceptionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventExceptionInclude | null
  /**
   * Filter, which EventExceptions to fetch.
  **/
  where?: EventExceptionWhereInput
  /**
   * Determine the order of the EventExceptions to fetch.
  **/
  orderBy?: EventExceptionOrderByInput
  /**
   * Sets the position for listing EventExceptions.
  **/
  cursor?: EventExceptionWhereUniqueInput
  /**
   * The number of EventExceptions to fetch. If negative number, it will take EventExceptions before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` EventExceptions.
  **/
  skip?: number
}


/**
 * EventException create
 */
export type EventExceptionCreateArgs = {
  /**
   * Select specific fields to fetch from the EventException
  **/
  select?: EventExceptionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventExceptionInclude | null
  /**
   * The data needed to create a EventException.
  **/
  data: EventExceptionCreateInput
}


/**
 * EventException update
 */
export type EventExceptionUpdateArgs = {
  /**
   * Select specific fields to fetch from the EventException
  **/
  select?: EventExceptionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventExceptionInclude | null
  /**
   * The data needed to update a EventException.
  **/
  data: EventExceptionUpdateInput
  /**
   * Choose, which EventException to update.
  **/
  where: EventExceptionWhereUniqueInput
}


/**
 * EventException updateMany
 */
export type EventExceptionUpdateManyArgs = {
  data: EventExceptionUpdateManyMutationInput
  where?: EventExceptionWhereInput
}


/**
 * EventException upsert
 */
export type EventExceptionUpsertArgs = {
  /**
   * Select specific fields to fetch from the EventException
  **/
  select?: EventExceptionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventExceptionInclude | null
  /**
   * The filter to search for the EventException to update in case it exists.
  **/
  where: EventExceptionWhereUniqueInput
  /**
   * In case the EventException found by the `where` argument doesn't exist, create a new EventException with this data.
  **/
  create: EventExceptionCreateInput
  /**
   * In case the EventException was found with the provided `where` argument, update it with this data.
  **/
  update: EventExceptionUpdateInput
}


/**
 * EventException delete
 */
export type EventExceptionDeleteArgs = {
  /**
   * Select specific fields to fetch from the EventException
  **/
  select?: EventExceptionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventExceptionInclude | null
  /**
   * Filter which EventException to delete.
  **/
  where: EventExceptionWhereUniqueInput
}


/**
 * EventException deleteMany
 */
export type EventExceptionDeleteManyArgs = {
  where?: EventExceptionWhereInput
}


/**
 * EventException without action
 */
export type EventExceptionArgs = {
  /**
   * Select specific fields to fetch from the EventException
  **/
  select?: EventExceptionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventExceptionInclude | null
}



/**
 * Model EventCancellation
 */

export type EventCancellation = {
  id: string
  createdAt: Date
  originalDate: Date
  parentId: string
}

export type EventCancellationSelect = {
  id?: boolean
  createdAt?: boolean
  originalDate?: boolean
  parent?: boolean | EventParentArgs
  parentId?: boolean
}

export type EventCancellationInclude = {
  parent?: boolean | EventParentArgs
}

export type EventCancellationGetPayload<
  S extends boolean | null | undefined | EventCancellationArgs,
  U = keyof S
> = S extends true
  ? EventCancellation
  : S extends undefined
  ? never
  : S extends EventCancellationArgs | FindManyEventCancellationArgs
  ? 'include' extends U
    ? EventCancellation  & {
      [P in TrueKeys<S['include']>]:
      P extends 'parent'
      ? EventParentGetPayload<S['include'][P]> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof EventCancellation ? EventCancellation[P]
: 
      P extends 'parent'
      ? EventParentGetPayload<S['select'][P]> : never
    }
  : EventCancellation
: EventCancellation


export interface EventCancellationDelegate {
  /**
   * Find zero or one EventCancellation.
   * @param {FindOneEventCancellationArgs} args - Arguments to find a EventCancellation
   * @example
   * // Get one EventCancellation
   * const eventCancellation = await prisma.eventCancellation.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneEventCancellationArgs>(
    args: Subset<T, FindOneEventCancellationArgs>
  ): CheckSelect<T, EventCancellationClient<EventCancellation | null>, EventCancellationClient<EventCancellationGetPayload<T> | null>>
  /**
   * Find zero or more EventCancellations.
   * @param {FindManyEventCancellationArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all EventCancellations
   * const eventCancellations = await prisma.eventCancellation.findMany()
   * 
   * // Get first 10 EventCancellations
   * const eventCancellations = await prisma.eventCancellation.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const eventCancellationWithIdOnly = await prisma.eventCancellation.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyEventCancellationArgs>(
    args?: Subset<T, FindManyEventCancellationArgs>
  ): CheckSelect<T, Promise<Array<EventCancellation>>, Promise<Array<EventCancellationGetPayload<T>>>>
  /**
   * Create a EventCancellation.
   * @param {EventCancellationCreateArgs} args - Arguments to create a EventCancellation.
   * @example
   * // Create one EventCancellation
   * const user = await prisma.eventCancellation.create({
   *   data: {
   *     // ... data to create a EventCancellation
   *   }
   * })
   * 
  **/
  create<T extends EventCancellationCreateArgs>(
    args: Subset<T, EventCancellationCreateArgs>
  ): CheckSelect<T, EventCancellationClient<EventCancellation>, EventCancellationClient<EventCancellationGetPayload<T>>>
  /**
   * Delete a EventCancellation.
   * @param {EventCancellationDeleteArgs} args - Arguments to delete one EventCancellation.
   * @example
   * // Delete one EventCancellation
   * const user = await prisma.eventCancellation.delete({
   *   where: {
   *     // ... filter to delete one EventCancellation
   *   }
   * })
   * 
  **/
  delete<T extends EventCancellationDeleteArgs>(
    args: Subset<T, EventCancellationDeleteArgs>
  ): CheckSelect<T, EventCancellationClient<EventCancellation>, EventCancellationClient<EventCancellationGetPayload<T>>>
  /**
   * Update one EventCancellation.
   * @param {EventCancellationUpdateArgs} args - Arguments to update one EventCancellation.
   * @example
   * // Update one EventCancellation
   * const eventCancellation = await prisma.eventCancellation.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends EventCancellationUpdateArgs>(
    args: Subset<T, EventCancellationUpdateArgs>
  ): CheckSelect<T, EventCancellationClient<EventCancellation>, EventCancellationClient<EventCancellationGetPayload<T>>>
  /**
   * Delete zero or more EventCancellations.
   * @param {EventCancellationDeleteManyArgs} args - Arguments to filter EventCancellations to delete.
   * @example
   * // Delete a few EventCancellations
   * const { count } = await prisma.eventCancellation.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends EventCancellationDeleteManyArgs>(
    args: Subset<T, EventCancellationDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more EventCancellations.
   * @param {EventCancellationUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many EventCancellations
   * const eventCancellation = await prisma.eventCancellation.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends EventCancellationUpdateManyArgs>(
    args: Subset<T, EventCancellationUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one EventCancellation.
   * @param {EventCancellationUpsertArgs} args - Arguments to update or create a EventCancellation.
   * @example
   * // Update or create a EventCancellation
   * const eventCancellation = await prisma.eventCancellation.upsert({
   *   create: {
   *     // ... data to create a EventCancellation
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the EventCancellation we want to update
   *   }
   * })
  **/
  upsert<T extends EventCancellationUpsertArgs>(
    args: Subset<T, EventCancellationUpsertArgs>
  ): CheckSelect<T, EventCancellationClient<EventCancellation>, EventCancellationClient<EventCancellationGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManyEventCancellationArgs, 'select' | 'include'>): Promise<number>
}

export declare class EventCancellationClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  parent<T extends EventParentArgs = {}>(args?: Subset<T, EventParentArgs>): CheckSelect<T, EventParentClient<EventParent | null>, EventParentClient<EventParentGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * EventCancellation findOne
 */
export type FindOneEventCancellationArgs = {
  /**
   * Select specific fields to fetch from the EventCancellation
  **/
  select?: EventCancellationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventCancellationInclude | null
  /**
   * Filter, which EventCancellation to fetch.
  **/
  where: EventCancellationWhereUniqueInput
}


/**
 * EventCancellation findMany
 */
export type FindManyEventCancellationArgs = {
  /**
   * Select specific fields to fetch from the EventCancellation
  **/
  select?: EventCancellationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventCancellationInclude | null
  /**
   * Filter, which EventCancellations to fetch.
  **/
  where?: EventCancellationWhereInput
  /**
   * Determine the order of the EventCancellations to fetch.
  **/
  orderBy?: EventCancellationOrderByInput
  /**
   * Sets the position for listing EventCancellations.
  **/
  cursor?: EventCancellationWhereUniqueInput
  /**
   * The number of EventCancellations to fetch. If negative number, it will take EventCancellations before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` EventCancellations.
  **/
  skip?: number
}


/**
 * EventCancellation create
 */
export type EventCancellationCreateArgs = {
  /**
   * Select specific fields to fetch from the EventCancellation
  **/
  select?: EventCancellationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventCancellationInclude | null
  /**
   * The data needed to create a EventCancellation.
  **/
  data: EventCancellationCreateInput
}


/**
 * EventCancellation update
 */
export type EventCancellationUpdateArgs = {
  /**
   * Select specific fields to fetch from the EventCancellation
  **/
  select?: EventCancellationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventCancellationInclude | null
  /**
   * The data needed to update a EventCancellation.
  **/
  data: EventCancellationUpdateInput
  /**
   * Choose, which EventCancellation to update.
  **/
  where: EventCancellationWhereUniqueInput
}


/**
 * EventCancellation updateMany
 */
export type EventCancellationUpdateManyArgs = {
  data: EventCancellationUpdateManyMutationInput
  where?: EventCancellationWhereInput
}


/**
 * EventCancellation upsert
 */
export type EventCancellationUpsertArgs = {
  /**
   * Select specific fields to fetch from the EventCancellation
  **/
  select?: EventCancellationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventCancellationInclude | null
  /**
   * The filter to search for the EventCancellation to update in case it exists.
  **/
  where: EventCancellationWhereUniqueInput
  /**
   * In case the EventCancellation found by the `where` argument doesn't exist, create a new EventCancellation with this data.
  **/
  create: EventCancellationCreateInput
  /**
   * In case the EventCancellation was found with the provided `where` argument, update it with this data.
  **/
  update: EventCancellationUpdateInput
}


/**
 * EventCancellation delete
 */
export type EventCancellationDeleteArgs = {
  /**
   * Select specific fields to fetch from the EventCancellation
  **/
  select?: EventCancellationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventCancellationInclude | null
  /**
   * Filter which EventCancellation to delete.
  **/
  where: EventCancellationWhereUniqueInput
}


/**
 * EventCancellation deleteMany
 */
export type EventCancellationDeleteManyArgs = {
  where?: EventCancellationWhereInput
}


/**
 * EventCancellation without action
 */
export type EventCancellationArgs = {
  /**
   * Select specific fields to fetch from the EventCancellation
  **/
  select?: EventCancellationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EventCancellationInclude | null
}



/**
 * Model Filter
 */

export type Filter = {
  id: string
  createdAt: Date
  name: string
  description: string | null
  type: FilterType
  accountId: string
}

export type FilterSelect = {
  id?: boolean
  createdAt?: boolean
  name?: boolean
  description?: boolean
  type?: boolean
  account?: boolean | AccountArgs
  accountId?: boolean
  events?: boolean | FindManyEventArgs
}

export type FilterInclude = {
  account?: boolean | AccountArgs
  events?: boolean | FindManyEventArgs
}

export type FilterGetPayload<
  S extends boolean | null | undefined | FilterArgs,
  U = keyof S
> = S extends true
  ? Filter
  : S extends undefined
  ? never
  : S extends FilterArgs | FindManyFilterArgs
  ? 'include' extends U
    ? Filter  & {
      [P in TrueKeys<S['include']>]:
      P extends 'account'
      ? AccountGetPayload<S['include'][P]> :
      P extends 'events'
      ? Array<EventGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Filter ? Filter[P]
: 
      P extends 'account'
      ? AccountGetPayload<S['select'][P]> :
      P extends 'events'
      ? Array<EventGetPayload<S['select'][P]>> : never
    }
  : Filter
: Filter


export interface FilterDelegate {
  /**
   * Find zero or one Filter.
   * @param {FindOneFilterArgs} args - Arguments to find a Filter
   * @example
   * // Get one Filter
   * const filter = await prisma.filter.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneFilterArgs>(
    args: Subset<T, FindOneFilterArgs>
  ): CheckSelect<T, FilterClient<Filter | null>, FilterClient<FilterGetPayload<T> | null>>
  /**
   * Find zero or more Filters.
   * @param {FindManyFilterArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Filters
   * const filters = await prisma.filter.findMany()
   * 
   * // Get first 10 Filters
   * const filters = await prisma.filter.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const filterWithIdOnly = await prisma.filter.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyFilterArgs>(
    args?: Subset<T, FindManyFilterArgs>
  ): CheckSelect<T, Promise<Array<Filter>>, Promise<Array<FilterGetPayload<T>>>>
  /**
   * Create a Filter.
   * @param {FilterCreateArgs} args - Arguments to create a Filter.
   * @example
   * // Create one Filter
   * const user = await prisma.filter.create({
   *   data: {
   *     // ... data to create a Filter
   *   }
   * })
   * 
  **/
  create<T extends FilterCreateArgs>(
    args: Subset<T, FilterCreateArgs>
  ): CheckSelect<T, FilterClient<Filter>, FilterClient<FilterGetPayload<T>>>
  /**
   * Delete a Filter.
   * @param {FilterDeleteArgs} args - Arguments to delete one Filter.
   * @example
   * // Delete one Filter
   * const user = await prisma.filter.delete({
   *   where: {
   *     // ... filter to delete one Filter
   *   }
   * })
   * 
  **/
  delete<T extends FilterDeleteArgs>(
    args: Subset<T, FilterDeleteArgs>
  ): CheckSelect<T, FilterClient<Filter>, FilterClient<FilterGetPayload<T>>>
  /**
   * Update one Filter.
   * @param {FilterUpdateArgs} args - Arguments to update one Filter.
   * @example
   * // Update one Filter
   * const filter = await prisma.filter.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends FilterUpdateArgs>(
    args: Subset<T, FilterUpdateArgs>
  ): CheckSelect<T, FilterClient<Filter>, FilterClient<FilterGetPayload<T>>>
  /**
   * Delete zero or more Filters.
   * @param {FilterDeleteManyArgs} args - Arguments to filter Filters to delete.
   * @example
   * // Delete a few Filters
   * const { count } = await prisma.filter.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends FilterDeleteManyArgs>(
    args: Subset<T, FilterDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Filters.
   * @param {FilterUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Filters
   * const filter = await prisma.filter.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends FilterUpdateManyArgs>(
    args: Subset<T, FilterUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Filter.
   * @param {FilterUpsertArgs} args - Arguments to update or create a Filter.
   * @example
   * // Update or create a Filter
   * const filter = await prisma.filter.upsert({
   *   create: {
   *     // ... data to create a Filter
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Filter we want to update
   *   }
   * })
  **/
  upsert<T extends FilterUpsertArgs>(
    args: Subset<T, FilterUpsertArgs>
  ): CheckSelect<T, FilterClient<Filter>, FilterClient<FilterGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManyFilterArgs, 'select' | 'include'>): Promise<number>
}

export declare class FilterClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  account<T extends AccountArgs = {}>(args?: Subset<T, AccountArgs>): CheckSelect<T, AccountClient<Account | null>, AccountClient<AccountGetPayload<T> | null>>;

  events<T extends FindManyEventArgs = {}>(args?: Subset<T, FindManyEventArgs>): CheckSelect<T, Promise<Array<Event>>, Promise<Array<EventGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Filter findOne
 */
export type FindOneFilterArgs = {
  /**
   * Select specific fields to fetch from the Filter
  **/
  select?: FilterSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: FilterInclude | null
  /**
   * Filter, which Filter to fetch.
  **/
  where: FilterWhereUniqueInput
}


/**
 * Filter findMany
 */
export type FindManyFilterArgs = {
  /**
   * Select specific fields to fetch from the Filter
  **/
  select?: FilterSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: FilterInclude | null
  /**
   * Filter, which Filters to fetch.
  **/
  where?: FilterWhereInput
  /**
   * Determine the order of the Filters to fetch.
  **/
  orderBy?: FilterOrderByInput
  /**
   * Sets the position for listing Filters.
  **/
  cursor?: FilterWhereUniqueInput
  /**
   * The number of Filters to fetch. If negative number, it will take Filters before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Filters.
  **/
  skip?: number
}


/**
 * Filter create
 */
export type FilterCreateArgs = {
  /**
   * Select specific fields to fetch from the Filter
  **/
  select?: FilterSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: FilterInclude | null
  /**
   * The data needed to create a Filter.
  **/
  data: FilterCreateInput
}


/**
 * Filter update
 */
export type FilterUpdateArgs = {
  /**
   * Select specific fields to fetch from the Filter
  **/
  select?: FilterSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: FilterInclude | null
  /**
   * The data needed to update a Filter.
  **/
  data: FilterUpdateInput
  /**
   * Choose, which Filter to update.
  **/
  where: FilterWhereUniqueInput
}


/**
 * Filter updateMany
 */
export type FilterUpdateManyArgs = {
  data: FilterUpdateManyMutationInput
  where?: FilterWhereInput
}


/**
 * Filter upsert
 */
export type FilterUpsertArgs = {
  /**
   * Select specific fields to fetch from the Filter
  **/
  select?: FilterSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: FilterInclude | null
  /**
   * The filter to search for the Filter to update in case it exists.
  **/
  where: FilterWhereUniqueInput
  /**
   * In case the Filter found by the `where` argument doesn't exist, create a new Filter with this data.
  **/
  create: FilterCreateInput
  /**
   * In case the Filter was found with the provided `where` argument, update it with this data.
  **/
  update: FilterUpdateInput
}


/**
 * Filter delete
 */
export type FilterDeleteArgs = {
  /**
   * Select specific fields to fetch from the Filter
  **/
  select?: FilterSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: FilterInclude | null
  /**
   * Filter which Filter to delete.
  **/
  where: FilterWhereUniqueInput
}


/**
 * Filter deleteMany
 */
export type FilterDeleteManyArgs = {
  where?: FilterWhereInput
}


/**
 * Filter without action
 */
export type FilterArgs = {
  /**
   * Select specific fields to fetch from the Filter
  **/
  select?: FilterSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: FilterInclude | null
}



/**
 * Model Booking
 */

export type Booking = {
  id: string
  createdAt: Date
  spaces: number
  cancelled: boolean
  eventExceptionId: string
  userId: string
  guestId: string | null
}

export type BookingSelect = {
  id?: boolean
  createdAt?: boolean
  spaces?: boolean
  cancelled?: boolean
  eventException?: boolean | EventExceptionArgs
  eventExceptionId?: boolean
  user?: boolean | UserArgs
  userId?: boolean
  guest?: boolean | GuestArgs
  guestId?: boolean
  cartBooking?: boolean | CartBookingArgs
}

export type BookingInclude = {
  eventException?: boolean | EventExceptionArgs
  user?: boolean | UserArgs
  guest?: boolean | GuestArgs
  cartBooking?: boolean | CartBookingArgs
}

export type BookingGetPayload<
  S extends boolean | null | undefined | BookingArgs,
  U = keyof S
> = S extends true
  ? Booking
  : S extends undefined
  ? never
  : S extends BookingArgs | FindManyBookingArgs
  ? 'include' extends U
    ? Booking  & {
      [P in TrueKeys<S['include']>]:
      P extends 'eventException'
      ? EventExceptionGetPayload<S['include'][P]> :
      P extends 'user'
      ? UserGetPayload<S['include'][P]> :
      P extends 'guest'
      ? GuestGetPayload<S['include'][P]> | null :
      P extends 'cartBooking'
      ? CartBookingGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Booking ? Booking[P]
: 
      P extends 'eventException'
      ? EventExceptionGetPayload<S['select'][P]> :
      P extends 'user'
      ? UserGetPayload<S['select'][P]> :
      P extends 'guest'
      ? GuestGetPayload<S['select'][P]> | null :
      P extends 'cartBooking'
      ? CartBookingGetPayload<S['select'][P]> | null : never
    }
  : Booking
: Booking


export interface BookingDelegate {
  /**
   * Find zero or one Booking.
   * @param {FindOneBookingArgs} args - Arguments to find a Booking
   * @example
   * // Get one Booking
   * const booking = await prisma.booking.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneBookingArgs>(
    args: Subset<T, FindOneBookingArgs>
  ): CheckSelect<T, BookingClient<Booking | null>, BookingClient<BookingGetPayload<T> | null>>
  /**
   * Find zero or more Bookings.
   * @param {FindManyBookingArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Bookings
   * const bookings = await prisma.booking.findMany()
   * 
   * // Get first 10 Bookings
   * const bookings = await prisma.booking.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyBookingArgs>(
    args?: Subset<T, FindManyBookingArgs>
  ): CheckSelect<T, Promise<Array<Booking>>, Promise<Array<BookingGetPayload<T>>>>
  /**
   * Create a Booking.
   * @param {BookingCreateArgs} args - Arguments to create a Booking.
   * @example
   * // Create one Booking
   * const user = await prisma.booking.create({
   *   data: {
   *     // ... data to create a Booking
   *   }
   * })
   * 
  **/
  create<T extends BookingCreateArgs>(
    args: Subset<T, BookingCreateArgs>
  ): CheckSelect<T, BookingClient<Booking>, BookingClient<BookingGetPayload<T>>>
  /**
   * Delete a Booking.
   * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
   * @example
   * // Delete one Booking
   * const user = await prisma.booking.delete({
   *   where: {
   *     // ... filter to delete one Booking
   *   }
   * })
   * 
  **/
  delete<T extends BookingDeleteArgs>(
    args: Subset<T, BookingDeleteArgs>
  ): CheckSelect<T, BookingClient<Booking>, BookingClient<BookingGetPayload<T>>>
  /**
   * Update one Booking.
   * @param {BookingUpdateArgs} args - Arguments to update one Booking.
   * @example
   * // Update one Booking
   * const booking = await prisma.booking.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends BookingUpdateArgs>(
    args: Subset<T, BookingUpdateArgs>
  ): CheckSelect<T, BookingClient<Booking>, BookingClient<BookingGetPayload<T>>>
  /**
   * Delete zero or more Bookings.
   * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
   * @example
   * // Delete a few Bookings
   * const { count } = await prisma.booking.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends BookingDeleteManyArgs>(
    args: Subset<T, BookingDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Bookings.
   * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Bookings
   * const booking = await prisma.booking.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends BookingUpdateManyArgs>(
    args: Subset<T, BookingUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Booking.
   * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
   * @example
   * // Update or create a Booking
   * const booking = await prisma.booking.upsert({
   *   create: {
   *     // ... data to create a Booking
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Booking we want to update
   *   }
   * })
  **/
  upsert<T extends BookingUpsertArgs>(
    args: Subset<T, BookingUpsertArgs>
  ): CheckSelect<T, BookingClient<Booking>, BookingClient<BookingGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManyBookingArgs, 'select' | 'include'>): Promise<number>
}

export declare class BookingClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  eventException<T extends EventExceptionArgs = {}>(args?: Subset<T, EventExceptionArgs>): CheckSelect<T, EventExceptionClient<EventException | null>, EventExceptionClient<EventExceptionGetPayload<T> | null>>;

  user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, UserClient<User | null>, UserClient<UserGetPayload<T> | null>>;

  guest<T extends GuestArgs = {}>(args?: Subset<T, GuestArgs>): CheckSelect<T, GuestClient<Guest | null>, GuestClient<GuestGetPayload<T> | null>>;

  cartBooking<T extends CartBookingArgs = {}>(args?: Subset<T, CartBookingArgs>): CheckSelect<T, CartBookingClient<CartBooking | null>, CartBookingClient<CartBookingGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Booking findOne
 */
export type FindOneBookingArgs = {
  /**
   * Select specific fields to fetch from the Booking
  **/
  select?: BookingSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: BookingInclude | null
  /**
   * Filter, which Booking to fetch.
  **/
  where: BookingWhereUniqueInput
}


/**
 * Booking findMany
 */
export type FindManyBookingArgs = {
  /**
   * Select specific fields to fetch from the Booking
  **/
  select?: BookingSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: BookingInclude | null
  /**
   * Filter, which Bookings to fetch.
  **/
  where?: BookingWhereInput
  /**
   * Determine the order of the Bookings to fetch.
  **/
  orderBy?: BookingOrderByInput
  /**
   * Sets the position for listing Bookings.
  **/
  cursor?: BookingWhereUniqueInput
  /**
   * The number of Bookings to fetch. If negative number, it will take Bookings before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Bookings.
  **/
  skip?: number
}


/**
 * Booking create
 */
export type BookingCreateArgs = {
  /**
   * Select specific fields to fetch from the Booking
  **/
  select?: BookingSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: BookingInclude | null
  /**
   * The data needed to create a Booking.
  **/
  data: BookingCreateInput
}


/**
 * Booking update
 */
export type BookingUpdateArgs = {
  /**
   * Select specific fields to fetch from the Booking
  **/
  select?: BookingSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: BookingInclude | null
  /**
   * The data needed to update a Booking.
  **/
  data: BookingUpdateInput
  /**
   * Choose, which Booking to update.
  **/
  where: BookingWhereUniqueInput
}


/**
 * Booking updateMany
 */
export type BookingUpdateManyArgs = {
  data: BookingUpdateManyMutationInput
  where?: BookingWhereInput
}


/**
 * Booking upsert
 */
export type BookingUpsertArgs = {
  /**
   * Select specific fields to fetch from the Booking
  **/
  select?: BookingSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: BookingInclude | null
  /**
   * The filter to search for the Booking to update in case it exists.
  **/
  where: BookingWhereUniqueInput
  /**
   * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
  **/
  create: BookingCreateInput
  /**
   * In case the Booking was found with the provided `where` argument, update it with this data.
  **/
  update: BookingUpdateInput
}


/**
 * Booking delete
 */
export type BookingDeleteArgs = {
  /**
   * Select specific fields to fetch from the Booking
  **/
  select?: BookingSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: BookingInclude | null
  /**
   * Filter which Booking to delete.
  **/
  where: BookingWhereUniqueInput
}


/**
 * Booking deleteMany
 */
export type BookingDeleteManyArgs = {
  where?: BookingWhereInput
}


/**
 * Booking without action
 */
export type BookingArgs = {
  /**
   * Select specific fields to fetch from the Booking
  **/
  select?: BookingSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: BookingInclude | null
}



/**
 * Model Guest
 */

export type Guest = {
  id: string
  email: string
  phoneNumber: string
}

export type GuestSelect = {
  id?: boolean
  email?: boolean
  phoneNumber?: boolean
  Booking?: boolean | FindManyBookingArgs
  Cart?: boolean | FindManyCartArgs
}

export type GuestInclude = {
  Booking?: boolean | FindManyBookingArgs
  Cart?: boolean | FindManyCartArgs
}

export type GuestGetPayload<
  S extends boolean | null | undefined | GuestArgs,
  U = keyof S
> = S extends true
  ? Guest
  : S extends undefined
  ? never
  : S extends GuestArgs | FindManyGuestArgs
  ? 'include' extends U
    ? Guest  & {
      [P in TrueKeys<S['include']>]:
      P extends 'Booking'
      ? Array<BookingGetPayload<S['include'][P]>> :
      P extends 'Cart'
      ? Array<CartGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Guest ? Guest[P]
: 
      P extends 'Booking'
      ? Array<BookingGetPayload<S['select'][P]>> :
      P extends 'Cart'
      ? Array<CartGetPayload<S['select'][P]>> : never
    }
  : Guest
: Guest


export interface GuestDelegate {
  /**
   * Find zero or one Guest.
   * @param {FindOneGuestArgs} args - Arguments to find a Guest
   * @example
   * // Get one Guest
   * const guest = await prisma.guest.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneGuestArgs>(
    args: Subset<T, FindOneGuestArgs>
  ): CheckSelect<T, GuestClient<Guest | null>, GuestClient<GuestGetPayload<T> | null>>
  /**
   * Find zero or more Guests.
   * @param {FindManyGuestArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Guests
   * const guests = await prisma.guest.findMany()
   * 
   * // Get first 10 Guests
   * const guests = await prisma.guest.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const guestWithIdOnly = await prisma.guest.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyGuestArgs>(
    args?: Subset<T, FindManyGuestArgs>
  ): CheckSelect<T, Promise<Array<Guest>>, Promise<Array<GuestGetPayload<T>>>>
  /**
   * Create a Guest.
   * @param {GuestCreateArgs} args - Arguments to create a Guest.
   * @example
   * // Create one Guest
   * const user = await prisma.guest.create({
   *   data: {
   *     // ... data to create a Guest
   *   }
   * })
   * 
  **/
  create<T extends GuestCreateArgs>(
    args: Subset<T, GuestCreateArgs>
  ): CheckSelect<T, GuestClient<Guest>, GuestClient<GuestGetPayload<T>>>
  /**
   * Delete a Guest.
   * @param {GuestDeleteArgs} args - Arguments to delete one Guest.
   * @example
   * // Delete one Guest
   * const user = await prisma.guest.delete({
   *   where: {
   *     // ... filter to delete one Guest
   *   }
   * })
   * 
  **/
  delete<T extends GuestDeleteArgs>(
    args: Subset<T, GuestDeleteArgs>
  ): CheckSelect<T, GuestClient<Guest>, GuestClient<GuestGetPayload<T>>>
  /**
   * Update one Guest.
   * @param {GuestUpdateArgs} args - Arguments to update one Guest.
   * @example
   * // Update one Guest
   * const guest = await prisma.guest.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends GuestUpdateArgs>(
    args: Subset<T, GuestUpdateArgs>
  ): CheckSelect<T, GuestClient<Guest>, GuestClient<GuestGetPayload<T>>>
  /**
   * Delete zero or more Guests.
   * @param {GuestDeleteManyArgs} args - Arguments to filter Guests to delete.
   * @example
   * // Delete a few Guests
   * const { count } = await prisma.guest.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends GuestDeleteManyArgs>(
    args: Subset<T, GuestDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Guests.
   * @param {GuestUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Guests
   * const guest = await prisma.guest.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends GuestUpdateManyArgs>(
    args: Subset<T, GuestUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Guest.
   * @param {GuestUpsertArgs} args - Arguments to update or create a Guest.
   * @example
   * // Update or create a Guest
   * const guest = await prisma.guest.upsert({
   *   create: {
   *     // ... data to create a Guest
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Guest we want to update
   *   }
   * })
  **/
  upsert<T extends GuestUpsertArgs>(
    args: Subset<T, GuestUpsertArgs>
  ): CheckSelect<T, GuestClient<Guest>, GuestClient<GuestGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManyGuestArgs, 'select' | 'include'>): Promise<number>
}

export declare class GuestClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  Booking<T extends FindManyBookingArgs = {}>(args?: Subset<T, FindManyBookingArgs>): CheckSelect<T, Promise<Array<Booking>>, Promise<Array<BookingGetPayload<T>>>>;

  Cart<T extends FindManyCartArgs = {}>(args?: Subset<T, FindManyCartArgs>): CheckSelect<T, Promise<Array<Cart>>, Promise<Array<CartGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Guest findOne
 */
export type FindOneGuestArgs = {
  /**
   * Select specific fields to fetch from the Guest
  **/
  select?: GuestSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: GuestInclude | null
  /**
   * Filter, which Guest to fetch.
  **/
  where: GuestWhereUniqueInput
}


/**
 * Guest findMany
 */
export type FindManyGuestArgs = {
  /**
   * Select specific fields to fetch from the Guest
  **/
  select?: GuestSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: GuestInclude | null
  /**
   * Filter, which Guests to fetch.
  **/
  where?: GuestWhereInput
  /**
   * Determine the order of the Guests to fetch.
  **/
  orderBy?: GuestOrderByInput
  /**
   * Sets the position for listing Guests.
  **/
  cursor?: GuestWhereUniqueInput
  /**
   * The number of Guests to fetch. If negative number, it will take Guests before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Guests.
  **/
  skip?: number
}


/**
 * Guest create
 */
export type GuestCreateArgs = {
  /**
   * Select specific fields to fetch from the Guest
  **/
  select?: GuestSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: GuestInclude | null
  /**
   * The data needed to create a Guest.
  **/
  data: GuestCreateInput
}


/**
 * Guest update
 */
export type GuestUpdateArgs = {
  /**
   * Select specific fields to fetch from the Guest
  **/
  select?: GuestSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: GuestInclude | null
  /**
   * The data needed to update a Guest.
  **/
  data: GuestUpdateInput
  /**
   * Choose, which Guest to update.
  **/
  where: GuestWhereUniqueInput
}


/**
 * Guest updateMany
 */
export type GuestUpdateManyArgs = {
  data: GuestUpdateManyMutationInput
  where?: GuestWhereInput
}


/**
 * Guest upsert
 */
export type GuestUpsertArgs = {
  /**
   * Select specific fields to fetch from the Guest
  **/
  select?: GuestSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: GuestInclude | null
  /**
   * The filter to search for the Guest to update in case it exists.
  **/
  where: GuestWhereUniqueInput
  /**
   * In case the Guest found by the `where` argument doesn't exist, create a new Guest with this data.
  **/
  create: GuestCreateInput
  /**
   * In case the Guest was found with the provided `where` argument, update it with this data.
  **/
  update: GuestUpdateInput
}


/**
 * Guest delete
 */
export type GuestDeleteArgs = {
  /**
   * Select specific fields to fetch from the Guest
  **/
  select?: GuestSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: GuestInclude | null
  /**
   * Filter which Guest to delete.
  **/
  where: GuestWhereUniqueInput
}


/**
 * Guest deleteMany
 */
export type GuestDeleteManyArgs = {
  where?: GuestWhereInput
}


/**
 * Guest without action
 */
export type GuestArgs = {
  /**
   * Select specific fields to fetch from the Guest
  **/
  select?: GuestSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: GuestInclude | null
}



/**
 * Model Cart
 */

export type Cart = {
  id: string
  createdAt: Date
  cartReference: string
  refunded: boolean
  paymentStatus: PaymentStatus
  stripe_paymentIntentId: string | null
  pendingItems: JsonValue
  userId: string
  guestId: string | null
  accountId: string
}

export type CartSelect = {
  id?: boolean
  createdAt?: boolean
  cartReference?: boolean
  refunded?: boolean
  paymentStatus?: boolean
  stripe_paymentIntentId?: boolean
  pendingItems?: boolean
  cartBooking?: boolean | FindManyCartBookingArgs
  user?: boolean | UserArgs
  userId?: boolean
  guest?: boolean | GuestArgs
  guestId?: boolean
  account?: boolean | AccountArgs
  accountId?: boolean
}

export type CartInclude = {
  cartBooking?: boolean | FindManyCartBookingArgs
  user?: boolean | UserArgs
  guest?: boolean | GuestArgs
  account?: boolean | AccountArgs
}

export type CartGetPayload<
  S extends boolean | null | undefined | CartArgs,
  U = keyof S
> = S extends true
  ? Cart
  : S extends undefined
  ? never
  : S extends CartArgs | FindManyCartArgs
  ? 'include' extends U
    ? Cart  & {
      [P in TrueKeys<S['include']>]:
      P extends 'cartBooking'
      ? Array<CartBookingGetPayload<S['include'][P]>> :
      P extends 'user'
      ? UserGetPayload<S['include'][P]> :
      P extends 'guest'
      ? GuestGetPayload<S['include'][P]> | null :
      P extends 'account'
      ? AccountGetPayload<S['include'][P]> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Cart ? Cart[P]
: 
      P extends 'cartBooking'
      ? Array<CartBookingGetPayload<S['select'][P]>> :
      P extends 'user'
      ? UserGetPayload<S['select'][P]> :
      P extends 'guest'
      ? GuestGetPayload<S['select'][P]> | null :
      P extends 'account'
      ? AccountGetPayload<S['select'][P]> : never
    }
  : Cart
: Cart


export interface CartDelegate {
  /**
   * Find zero or one Cart.
   * @param {FindOneCartArgs} args - Arguments to find a Cart
   * @example
   * // Get one Cart
   * const cart = await prisma.cart.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneCartArgs>(
    args: Subset<T, FindOneCartArgs>
  ): CheckSelect<T, CartClient<Cart | null>, CartClient<CartGetPayload<T> | null>>
  /**
   * Find zero or more Carts.
   * @param {FindManyCartArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Carts
   * const carts = await prisma.cart.findMany()
   * 
   * // Get first 10 Carts
   * const carts = await prisma.cart.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const cartWithIdOnly = await prisma.cart.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyCartArgs>(
    args?: Subset<T, FindManyCartArgs>
  ): CheckSelect<T, Promise<Array<Cart>>, Promise<Array<CartGetPayload<T>>>>
  /**
   * Create a Cart.
   * @param {CartCreateArgs} args - Arguments to create a Cart.
   * @example
   * // Create one Cart
   * const user = await prisma.cart.create({
   *   data: {
   *     // ... data to create a Cart
   *   }
   * })
   * 
  **/
  create<T extends CartCreateArgs>(
    args: Subset<T, CartCreateArgs>
  ): CheckSelect<T, CartClient<Cart>, CartClient<CartGetPayload<T>>>
  /**
   * Delete a Cart.
   * @param {CartDeleteArgs} args - Arguments to delete one Cart.
   * @example
   * // Delete one Cart
   * const user = await prisma.cart.delete({
   *   where: {
   *     // ... filter to delete one Cart
   *   }
   * })
   * 
  **/
  delete<T extends CartDeleteArgs>(
    args: Subset<T, CartDeleteArgs>
  ): CheckSelect<T, CartClient<Cart>, CartClient<CartGetPayload<T>>>
  /**
   * Update one Cart.
   * @param {CartUpdateArgs} args - Arguments to update one Cart.
   * @example
   * // Update one Cart
   * const cart = await prisma.cart.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends CartUpdateArgs>(
    args: Subset<T, CartUpdateArgs>
  ): CheckSelect<T, CartClient<Cart>, CartClient<CartGetPayload<T>>>
  /**
   * Delete zero or more Carts.
   * @param {CartDeleteManyArgs} args - Arguments to filter Carts to delete.
   * @example
   * // Delete a few Carts
   * const { count } = await prisma.cart.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends CartDeleteManyArgs>(
    args: Subset<T, CartDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Carts.
   * @param {CartUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Carts
   * const cart = await prisma.cart.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends CartUpdateManyArgs>(
    args: Subset<T, CartUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Cart.
   * @param {CartUpsertArgs} args - Arguments to update or create a Cart.
   * @example
   * // Update or create a Cart
   * const cart = await prisma.cart.upsert({
   *   create: {
   *     // ... data to create a Cart
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Cart we want to update
   *   }
   * })
  **/
  upsert<T extends CartUpsertArgs>(
    args: Subset<T, CartUpsertArgs>
  ): CheckSelect<T, CartClient<Cart>, CartClient<CartGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManyCartArgs, 'select' | 'include'>): Promise<number>
}

export declare class CartClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  cartBooking<T extends FindManyCartBookingArgs = {}>(args?: Subset<T, FindManyCartBookingArgs>): CheckSelect<T, Promise<Array<CartBooking>>, Promise<Array<CartBookingGetPayload<T>>>>;

  user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, UserClient<User | null>, UserClient<UserGetPayload<T> | null>>;

  guest<T extends GuestArgs = {}>(args?: Subset<T, GuestArgs>): CheckSelect<T, GuestClient<Guest | null>, GuestClient<GuestGetPayload<T> | null>>;

  account<T extends AccountArgs = {}>(args?: Subset<T, AccountArgs>): CheckSelect<T, AccountClient<Account | null>, AccountClient<AccountGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Cart findOne
 */
export type FindOneCartArgs = {
  /**
   * Select specific fields to fetch from the Cart
  **/
  select?: CartSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CartInclude | null
  /**
   * Filter, which Cart to fetch.
  **/
  where: CartWhereUniqueInput
}


/**
 * Cart findMany
 */
export type FindManyCartArgs = {
  /**
   * Select specific fields to fetch from the Cart
  **/
  select?: CartSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CartInclude | null
  /**
   * Filter, which Carts to fetch.
  **/
  where?: CartWhereInput
  /**
   * Determine the order of the Carts to fetch.
  **/
  orderBy?: CartOrderByInput
  /**
   * Sets the position for listing Carts.
  **/
  cursor?: CartWhereUniqueInput
  /**
   * The number of Carts to fetch. If negative number, it will take Carts before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Carts.
  **/
  skip?: number
}


/**
 * Cart create
 */
export type CartCreateArgs = {
  /**
   * Select specific fields to fetch from the Cart
  **/
  select?: CartSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CartInclude | null
  /**
   * The data needed to create a Cart.
  **/
  data: CartCreateInput
}


/**
 * Cart update
 */
export type CartUpdateArgs = {
  /**
   * Select specific fields to fetch from the Cart
  **/
  select?: CartSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CartInclude | null
  /**
   * The data needed to update a Cart.
  **/
  data: CartUpdateInput
  /**
   * Choose, which Cart to update.
  **/
  where: CartWhereUniqueInput
}


/**
 * Cart updateMany
 */
export type CartUpdateManyArgs = {
  data: CartUpdateManyMutationInput
  where?: CartWhereInput
}


/**
 * Cart upsert
 */
export type CartUpsertArgs = {
  /**
   * Select specific fields to fetch from the Cart
  **/
  select?: CartSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CartInclude | null
  /**
   * The filter to search for the Cart to update in case it exists.
  **/
  where: CartWhereUniqueInput
  /**
   * In case the Cart found by the `where` argument doesn't exist, create a new Cart with this data.
  **/
  create: CartCreateInput
  /**
   * In case the Cart was found with the provided `where` argument, update it with this data.
  **/
  update: CartUpdateInput
}


/**
 * Cart delete
 */
export type CartDeleteArgs = {
  /**
   * Select specific fields to fetch from the Cart
  **/
  select?: CartSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CartInclude | null
  /**
   * Filter which Cart to delete.
  **/
  where: CartWhereUniqueInput
}


/**
 * Cart deleteMany
 */
export type CartDeleteManyArgs = {
  where?: CartWhereInput
}


/**
 * Cart without action
 */
export type CartArgs = {
  /**
   * Select specific fields to fetch from the Cart
  **/
  select?: CartSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CartInclude | null
}



/**
 * Model CartBooking
 */

export type CartBooking = {
  id: string
  refunded: boolean
  paymentAmount: number
  cartId: string
  bookingId: string
  accountId: string | null
}

export type CartBookingSelect = {
  id?: boolean
  refunded?: boolean
  paymentAmount?: boolean
  cart?: boolean | CartArgs
  cartId?: boolean
  booking?: boolean | BookingArgs
  bookingId?: boolean
  Account?: boolean | AccountArgs
  accountId?: boolean
}

export type CartBookingInclude = {
  cart?: boolean | CartArgs
  booking?: boolean | BookingArgs
  Account?: boolean | AccountArgs
}

export type CartBookingGetPayload<
  S extends boolean | null | undefined | CartBookingArgs,
  U = keyof S
> = S extends true
  ? CartBooking
  : S extends undefined
  ? never
  : S extends CartBookingArgs | FindManyCartBookingArgs
  ? 'include' extends U
    ? CartBooking  & {
      [P in TrueKeys<S['include']>]:
      P extends 'cart'
      ? CartGetPayload<S['include'][P]> :
      P extends 'booking'
      ? BookingGetPayload<S['include'][P]> :
      P extends 'Account'
      ? AccountGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof CartBooking ? CartBooking[P]
: 
      P extends 'cart'
      ? CartGetPayload<S['select'][P]> :
      P extends 'booking'
      ? BookingGetPayload<S['select'][P]> :
      P extends 'Account'
      ? AccountGetPayload<S['select'][P]> | null : never
    }
  : CartBooking
: CartBooking


export interface CartBookingDelegate {
  /**
   * Find zero or one CartBooking.
   * @param {FindOneCartBookingArgs} args - Arguments to find a CartBooking
   * @example
   * // Get one CartBooking
   * const cartBooking = await prisma.cartBooking.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneCartBookingArgs>(
    args: Subset<T, FindOneCartBookingArgs>
  ): CheckSelect<T, CartBookingClient<CartBooking | null>, CartBookingClient<CartBookingGetPayload<T> | null>>
  /**
   * Find zero or more CartBookings.
   * @param {FindManyCartBookingArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all CartBookings
   * const cartBookings = await prisma.cartBooking.findMany()
   * 
   * // Get first 10 CartBookings
   * const cartBookings = await prisma.cartBooking.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const cartBookingWithIdOnly = await prisma.cartBooking.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyCartBookingArgs>(
    args?: Subset<T, FindManyCartBookingArgs>
  ): CheckSelect<T, Promise<Array<CartBooking>>, Promise<Array<CartBookingGetPayload<T>>>>
  /**
   * Create a CartBooking.
   * @param {CartBookingCreateArgs} args - Arguments to create a CartBooking.
   * @example
   * // Create one CartBooking
   * const user = await prisma.cartBooking.create({
   *   data: {
   *     // ... data to create a CartBooking
   *   }
   * })
   * 
  **/
  create<T extends CartBookingCreateArgs>(
    args: Subset<T, CartBookingCreateArgs>
  ): CheckSelect<T, CartBookingClient<CartBooking>, CartBookingClient<CartBookingGetPayload<T>>>
  /**
   * Delete a CartBooking.
   * @param {CartBookingDeleteArgs} args - Arguments to delete one CartBooking.
   * @example
   * // Delete one CartBooking
   * const user = await prisma.cartBooking.delete({
   *   where: {
   *     // ... filter to delete one CartBooking
   *   }
   * })
   * 
  **/
  delete<T extends CartBookingDeleteArgs>(
    args: Subset<T, CartBookingDeleteArgs>
  ): CheckSelect<T, CartBookingClient<CartBooking>, CartBookingClient<CartBookingGetPayload<T>>>
  /**
   * Update one CartBooking.
   * @param {CartBookingUpdateArgs} args - Arguments to update one CartBooking.
   * @example
   * // Update one CartBooking
   * const cartBooking = await prisma.cartBooking.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends CartBookingUpdateArgs>(
    args: Subset<T, CartBookingUpdateArgs>
  ): CheckSelect<T, CartBookingClient<CartBooking>, CartBookingClient<CartBookingGetPayload<T>>>
  /**
   * Delete zero or more CartBookings.
   * @param {CartBookingDeleteManyArgs} args - Arguments to filter CartBookings to delete.
   * @example
   * // Delete a few CartBookings
   * const { count } = await prisma.cartBooking.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends CartBookingDeleteManyArgs>(
    args: Subset<T, CartBookingDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more CartBookings.
   * @param {CartBookingUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many CartBookings
   * const cartBooking = await prisma.cartBooking.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends CartBookingUpdateManyArgs>(
    args: Subset<T, CartBookingUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one CartBooking.
   * @param {CartBookingUpsertArgs} args - Arguments to update or create a CartBooking.
   * @example
   * // Update or create a CartBooking
   * const cartBooking = await prisma.cartBooking.upsert({
   *   create: {
   *     // ... data to create a CartBooking
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the CartBooking we want to update
   *   }
   * })
  **/
  upsert<T extends CartBookingUpsertArgs>(
    args: Subset<T, CartBookingUpsertArgs>
  ): CheckSelect<T, CartBookingClient<CartBooking>, CartBookingClient<CartBookingGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManyCartBookingArgs, 'select' | 'include'>): Promise<number>
}

export declare class CartBookingClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  cart<T extends CartArgs = {}>(args?: Subset<T, CartArgs>): CheckSelect<T, CartClient<Cart | null>, CartClient<CartGetPayload<T> | null>>;

  booking<T extends BookingArgs = {}>(args?: Subset<T, BookingArgs>): CheckSelect<T, BookingClient<Booking | null>, BookingClient<BookingGetPayload<T> | null>>;

  Account<T extends AccountArgs = {}>(args?: Subset<T, AccountArgs>): CheckSelect<T, AccountClient<Account | null>, AccountClient<AccountGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * CartBooking findOne
 */
export type FindOneCartBookingArgs = {
  /**
   * Select specific fields to fetch from the CartBooking
  **/
  select?: CartBookingSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CartBookingInclude | null
  /**
   * Filter, which CartBooking to fetch.
  **/
  where: CartBookingWhereUniqueInput
}


/**
 * CartBooking findMany
 */
export type FindManyCartBookingArgs = {
  /**
   * Select specific fields to fetch from the CartBooking
  **/
  select?: CartBookingSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CartBookingInclude | null
  /**
   * Filter, which CartBookings to fetch.
  **/
  where?: CartBookingWhereInput
  /**
   * Determine the order of the CartBookings to fetch.
  **/
  orderBy?: CartBookingOrderByInput
  /**
   * Sets the position for listing CartBookings.
  **/
  cursor?: CartBookingWhereUniqueInput
  /**
   * The number of CartBookings to fetch. If negative number, it will take CartBookings before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` CartBookings.
  **/
  skip?: number
}


/**
 * CartBooking create
 */
export type CartBookingCreateArgs = {
  /**
   * Select specific fields to fetch from the CartBooking
  **/
  select?: CartBookingSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CartBookingInclude | null
  /**
   * The data needed to create a CartBooking.
  **/
  data: CartBookingCreateInput
}


/**
 * CartBooking update
 */
export type CartBookingUpdateArgs = {
  /**
   * Select specific fields to fetch from the CartBooking
  **/
  select?: CartBookingSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CartBookingInclude | null
  /**
   * The data needed to update a CartBooking.
  **/
  data: CartBookingUpdateInput
  /**
   * Choose, which CartBooking to update.
  **/
  where: CartBookingWhereUniqueInput
}


/**
 * CartBooking updateMany
 */
export type CartBookingUpdateManyArgs = {
  data: CartBookingUpdateManyMutationInput
  where?: CartBookingWhereInput
}


/**
 * CartBooking upsert
 */
export type CartBookingUpsertArgs = {
  /**
   * Select specific fields to fetch from the CartBooking
  **/
  select?: CartBookingSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CartBookingInclude | null
  /**
   * The filter to search for the CartBooking to update in case it exists.
  **/
  where: CartBookingWhereUniqueInput
  /**
   * In case the CartBooking found by the `where` argument doesn't exist, create a new CartBooking with this data.
  **/
  create: CartBookingCreateInput
  /**
   * In case the CartBooking was found with the provided `where` argument, update it with this data.
  **/
  update: CartBookingUpdateInput
}


/**
 * CartBooking delete
 */
export type CartBookingDeleteArgs = {
  /**
   * Select specific fields to fetch from the CartBooking
  **/
  select?: CartBookingSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CartBookingInclude | null
  /**
   * Filter which CartBooking to delete.
  **/
  where: CartBookingWhereUniqueInput
}


/**
 * CartBooking deleteMany
 */
export type CartBookingDeleteManyArgs = {
  where?: CartBookingWhereInput
}


/**
 * CartBooking without action
 */
export type CartBookingArgs = {
  /**
   * Select specific fields to fetch from the CartBooking
  **/
  select?: CartBookingSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: CartBookingInclude | null
}



/**
 * Deep Input Types
 */


export type EventCancellationWhereInput = {
  id?: string | UUIDFilter
  createdAt?: Date | string | DateTimeFilter
  originalDate?: Date | string | DateTimeFilter
  parentId?: string | StringFilter
  AND?: Enumerable<EventCancellationWhereInput>
  OR?: Array<EventCancellationWhereInput>
  NOT?: Enumerable<EventCancellationWhereInput>
  parent?: EventParentWhereInput | null
}

export type FilterWhereInput = {
  id?: string | UUIDFilter
  createdAt?: Date | string | DateTimeFilter
  name?: string | StringFilter
  description?: string | NullableStringFilter | null
  type?: FilterType | FilterTypeFilter
  accountId?: string | StringFilter
  events?: EventFilter | null
  AND?: Enumerable<FilterWhereInput>
  OR?: Array<FilterWhereInput>
  NOT?: Enumerable<FilterWhereInput>
  account?: AccountWhereInput | null
}

export type EventWhereInput = {
  id?: string | UUIDFilter
  createdAt?: Date | string | DateTimeFilter
  title?: string | StringFilter
  description?: string | StringFilter
  price?: number | IntFilter
  spaces?: number | IntFilter
  duration?: number | FloatFilter
  filters?: FilterFilter | null
  eventParents?: EventParentFilter | null
  eventExceptions?: EventExceptionFilter | null
  AND?: Enumerable<EventWhereInput>
  OR?: Array<EventWhereInput>
  NOT?: Enumerable<EventWhereInput>
}

export type EventParentWhereInput = {
  id?: string | UUIDFilter
  createdAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  isPublished?: boolean | BooleanFilter
  rule?: string | StringFilter
  createdByUserId?: string | StringFilter
  accountId?: string | StringFilter
  exceptions?: EventExceptionFilter | null
  cancellations?: EventCancellationFilter | null
  eventId?: string | StringFilter
  AND?: Enumerable<EventParentWhereInput>
  OR?: Array<EventParentWhereInput>
  NOT?: Enumerable<EventParentWhereInput>
  createdBy?: UserWhereInput | null
  account?: AccountWhereInput | null
  event?: EventWhereInput | null
}

export type EventExceptionWhereInput = {
  id?: string | UUIDFilter
  createdAt?: Date | string | DateTimeFilter
  originalDate?: Date | string | DateTimeFilter
  date?: Date | string | DateTimeFilter
  cancelled?: boolean | BooleanFilter
  bookings?: BookingFilter | null
  parentId?: string | StringFilter
  eventId?: string | StringFilter
  AND?: Enumerable<EventExceptionWhereInput>
  OR?: Array<EventExceptionWhereInput>
  NOT?: Enumerable<EventExceptionWhereInput>
  parent?: EventParentWhereInput | null
  event?: EventWhereInput | null
}

export type CartBookingWhereInput = {
  id?: string | UUIDFilter
  refunded?: boolean | BooleanFilter
  paymentAmount?: number | IntFilter
  cartId?: string | StringFilter
  bookingId?: string | StringFilter
  accountId?: string | NullableStringFilter | null
  AND?: Enumerable<CartBookingWhereInput>
  OR?: Array<CartBookingWhereInput>
  NOT?: Enumerable<CartBookingWhereInput>
  cart?: CartWhereInput | null
  booking?: BookingWhereInput | null
  Account?: AccountWhereInput | null
}

export type CartWhereInput = {
  id?: string | UUIDFilter
  createdAt?: Date | string | DateTimeFilter
  cartReference?: string | StringFilter
  refunded?: boolean | BooleanFilter
  paymentStatus?: PaymentStatus | PaymentStatusFilter
  stripe_paymentIntentId?: string | NullableStringFilter | null
  pendingItems?: JsonValue | JsonFilter
  cartBooking?: CartBookingFilter | null
  userId?: string | StringFilter
  guestId?: string | NullableStringFilter | null
  accountId?: string | StringFilter
  AND?: Enumerable<CartWhereInput>
  OR?: Array<CartWhereInput>
  NOT?: Enumerable<CartWhereInput>
  user?: UserWhereInput | null
  guest?: GuestWhereInput | null
  account?: AccountWhereInput | null
}

export type GuestWhereInput = {
  id?: string | UUIDFilter
  email?: string | StringFilter
  phoneNumber?: string | StringFilter
  Booking?: BookingFilter | null
  Cart?: CartFilter | null
  AND?: Enumerable<GuestWhereInput>
  OR?: Array<GuestWhereInput>
  NOT?: Enumerable<GuestWhereInput>
}

export type BookingWhereInput = {
  id?: string | UUIDFilter
  createdAt?: Date | string | DateTimeFilter
  spaces?: number | IntFilter
  cancelled?: boolean | BooleanFilter
  eventExceptionId?: string | StringFilter
  userId?: string | StringFilter
  guestId?: string | NullableStringFilter | null
  AND?: Enumerable<BookingWhereInput>
  OR?: Array<BookingWhereInput>
  NOT?: Enumerable<BookingWhereInput>
  eventException?: EventExceptionWhereInput | null
  user?: UserWhereInput | null
  guest?: GuestWhereInput | null
  cartBooking?: CartBookingWhereInput | null
}

export type UserWhereInput = {
  id?: string | UUIDFilter
  createdAt?: Date | string | DateTimeFilter
  auth0_userId?: string | StringFilter
  isGuest?: boolean | NullableBooleanFilter | null
  bookings?: BookingFilter | null
  eventParents?: EventParentFilter | null
  Cart?: CartFilter | null
  AND?: Enumerable<UserWhereInput>
  OR?: Array<UserWhereInput>
  NOT?: Enumerable<UserWhereInput>
  account?: AccountWhereInput | null
}

export type AccountWhereInput = {
  id?: string | UUIDFilter
  createdAt?: Date | string | DateTimeFilter
  settings?: string | StringFilter
  stripe_accountId?: string | NullableStringFilter | null
  stripe_refreshToken?: string | NullableStringFilter | null
  stripe_customerId?: string | NullableStringFilter | null
  stripe_subscriptionStatus?: string | NullableStringFilter | null
  ownerId?: string | StringFilter
  eventParents?: EventParentFilter | null
  filters?: FilterFilter | null
  CartBooking?: CartBookingFilter | null
  Cart?: CartFilter | null
  AND?: Enumerable<AccountWhereInput>
  OR?: Array<AccountWhereInput>
  NOT?: Enumerable<AccountWhereInput>
  owner?: UserWhereInput | null
}

export type AccountWhereUniqueInput = {
  id?: string
  stripe_accountId?: string | null
  stripe_customerId?: string | null
}

export type BookingWhereUniqueInput = {
  id?: string
}

export type EventExceptionWhereUniqueInput = {
  id?: string
}

export type EventCancellationWhereUniqueInput = {
  id?: string
}

export type FilterWhereUniqueInput = {
  id?: string
}

export type EventWhereUniqueInput = {
  id?: string
}

export type EventParentWhereUniqueInput = {
  id?: string
}

export type CartWhereUniqueInput = {
  id?: string
  stripe_paymentIntentId?: string | null
}

export type CartBookingWhereUniqueInput = {
  id?: string
}

export type UserWhereUniqueInput = {
  id?: string
  auth0_userId?: string
  isGuest?: boolean | null
}

export type GuestWhereUniqueInput = {
  id?: string
}

export type EventCancellationCreateWithoutParentInput = {
  id?: string
  createdAt?: Date | string
  originalDate: Date | string
}

export type EventCancellationCreateManyWithoutParentInput = {
  create?: Enumerable<EventCancellationCreateWithoutParentInput>
  connect?: Enumerable<EventCancellationWhereUniqueInput>
}

export type EventParentCreateWithoutEventInput = {
  id?: string
  createdAt?: Date | string
  deletedAt?: Date | string | null
  isPublished: boolean
  rule: string
  createdBy: UserCreateOneWithoutEventParentsInput
  account: AccountCreateOneWithoutEventParentsInput
  exceptions?: EventExceptionCreateManyWithoutParentInput | null
  cancellations?: EventCancellationCreateManyWithoutParentInput | null
}

export type EventParentCreateManyWithoutEventInput = {
  create?: Enumerable<EventParentCreateWithoutEventInput>
  connect?: Enumerable<EventParentWhereUniqueInput>
}

export type EventExceptionCreateWithoutEventInput = {
  id?: string
  createdAt?: Date | string
  originalDate: Date | string
  date: Date | string
  cancelled?: boolean
  bookings?: BookingCreateManyWithoutEventExceptionInput | null
  parent: EventParentCreateOneWithoutExceptionsInput
}

export type EventExceptionCreateManyWithoutEventInput = {
  create?: Enumerable<EventExceptionCreateWithoutEventInput>
  connect?: Enumerable<EventExceptionWhereUniqueInput>
}

export type EventCreateWithoutFiltersInput = {
  id?: string
  createdAt?: Date | string
  title: string
  description: string
  price: number
  spaces: number
  duration: number
  eventParents?: EventParentCreateManyWithoutEventInput | null
  eventExceptions?: EventExceptionCreateManyWithoutEventInput | null
}

export type EventCreateManyWithoutFiltersInput = {
  create?: Enumerable<EventCreateWithoutFiltersInput>
  connect?: Enumerable<EventWhereUniqueInput>
}

export type FilterCreateWithoutAccountInput = {
  id?: string
  createdAt?: Date | string
  name: string
  description?: string | null
  type: FilterType
  events?: EventCreateManyWithoutFiltersInput | null
}

export type FilterCreateManyWithoutAccountInput = {
  create?: Enumerable<FilterCreateWithoutAccountInput>
  connect?: Enumerable<FilterWhereUniqueInput>
}

export type UserCreateWithoutCartInput = {
  id?: string
  createdAt?: Date | string
  auth0_userId: string
  isGuest?: boolean | null
  bookings?: BookingCreateManyWithoutUserInput | null
  account?: AccountCreateOneWithoutOwnerInput | null
  eventParents?: EventParentCreateManyWithoutCreatedByInput | null
}

export type UserCreateOneWithoutCartInput = {
  create?: UserCreateWithoutCartInput
  connect?: UserWhereUniqueInput
}

export type AccountCreateWithoutCartInput = {
  id?: string
  createdAt?: Date | string
  settings: string
  stripe_accountId?: string | null
  stripe_refreshToken?: string | null
  stripe_customerId?: string | null
  stripe_subscriptionStatus?: string | null
  owner: UserCreateOneWithoutAccountInput
  eventParents?: EventParentCreateManyWithoutAccountInput | null
  filters?: FilterCreateManyWithoutAccountInput | null
  CartBooking?: CartBookingCreateManyWithoutAccountInput | null
}

export type AccountCreateOneWithoutCartInput = {
  create?: AccountCreateWithoutCartInput
  connect?: AccountWhereUniqueInput
}

export type CartCreateWithoutGuestInput = {
  id?: string
  createdAt?: Date | string
  cartReference: string
  refunded?: boolean
  paymentStatus?: PaymentStatus
  stripe_paymentIntentId?: string | null
  pendingItems: JsonValue
  cartBooking?: CartBookingCreateManyWithoutCartInput | null
  user: UserCreateOneWithoutCartInput
  account: AccountCreateOneWithoutCartInput
}

export type CartCreateManyWithoutGuestInput = {
  create?: Enumerable<CartCreateWithoutGuestInput>
  connect?: Enumerable<CartWhereUniqueInput>
}

export type GuestCreateWithoutBookingInput = {
  id?: string
  email: string
  phoneNumber: string
  Cart?: CartCreateManyWithoutGuestInput | null
}

export type GuestCreateOneWithoutBookingInput = {
  create?: GuestCreateWithoutBookingInput
  connect?: GuestWhereUniqueInput
}

export type BookingCreateWithoutCartBookingInput = {
  id?: string
  createdAt?: Date | string
  spaces: number
  cancelled?: boolean
  eventException: EventExceptionCreateOneWithoutBookingsInput
  user: UserCreateOneWithoutBookingsInput
  guest?: GuestCreateOneWithoutBookingInput | null
}

export type BookingCreateOneWithoutCartBookingInput = {
  create?: BookingCreateWithoutCartBookingInput
  connect?: BookingWhereUniqueInput
}

export type CartBookingCreateWithoutCartInput = {
  id?: string
  refunded?: boolean
  paymentAmount: number
  booking: BookingCreateOneWithoutCartBookingInput
  Account?: AccountCreateOneWithoutCartBookingInput | null
}

export type CartBookingCreateManyWithoutCartInput = {
  create?: Enumerable<CartBookingCreateWithoutCartInput>
  connect?: Enumerable<CartBookingWhereUniqueInput>
}

export type CartCreateWithoutAccountInput = {
  id?: string
  createdAt?: Date | string
  cartReference: string
  refunded?: boolean
  paymentStatus?: PaymentStatus
  stripe_paymentIntentId?: string | null
  pendingItems: JsonValue
  cartBooking?: CartBookingCreateManyWithoutCartInput | null
  user: UserCreateOneWithoutCartInput
  guest?: GuestCreateOneWithoutCartInput | null
}

export type CartCreateManyWithoutAccountInput = {
  create?: Enumerable<CartCreateWithoutAccountInput>
  connect?: Enumerable<CartWhereUniqueInput>
}

export type AccountCreateWithoutCartBookingInput = {
  id?: string
  createdAt?: Date | string
  settings: string
  stripe_accountId?: string | null
  stripe_refreshToken?: string | null
  stripe_customerId?: string | null
  stripe_subscriptionStatus?: string | null
  owner: UserCreateOneWithoutAccountInput
  eventParents?: EventParentCreateManyWithoutAccountInput | null
  filters?: FilterCreateManyWithoutAccountInput | null
  Cart?: CartCreateManyWithoutAccountInput | null
}

export type AccountCreateOneWithoutCartBookingInput = {
  create?: AccountCreateWithoutCartBookingInput
  connect?: AccountWhereUniqueInput
}

export type CartBookingCreateWithoutBookingInput = {
  id?: string
  refunded?: boolean
  paymentAmount: number
  cart: CartCreateOneWithoutCartBookingInput
  Account?: AccountCreateOneWithoutCartBookingInput | null
}

export type CartBookingCreateOneWithoutBookingInput = {
  create?: CartBookingCreateWithoutBookingInput
  connect?: CartBookingWhereUniqueInput
}

export type BookingCreateWithoutGuestInput = {
  id?: string
  createdAt?: Date | string
  spaces: number
  cancelled?: boolean
  eventException: EventExceptionCreateOneWithoutBookingsInput
  user: UserCreateOneWithoutBookingsInput
  cartBooking?: CartBookingCreateOneWithoutBookingInput | null
}

export type BookingCreateManyWithoutGuestInput = {
  create?: Enumerable<BookingCreateWithoutGuestInput>
  connect?: Enumerable<BookingWhereUniqueInput>
}

export type GuestCreateWithoutCartInput = {
  id?: string
  email: string
  phoneNumber: string
  Booking?: BookingCreateManyWithoutGuestInput | null
}

export type GuestCreateOneWithoutCartInput = {
  create?: GuestCreateWithoutCartInput
  connect?: GuestWhereUniqueInput
}

export type CartCreateWithoutCartBookingInput = {
  id?: string
  createdAt?: Date | string
  cartReference: string
  refunded?: boolean
  paymentStatus?: PaymentStatus
  stripe_paymentIntentId?: string | null
  pendingItems: JsonValue
  user: UserCreateOneWithoutCartInput
  guest?: GuestCreateOneWithoutCartInput | null
  account: AccountCreateOneWithoutCartInput
}

export type CartCreateOneWithoutCartBookingInput = {
  create?: CartCreateWithoutCartBookingInput
  connect?: CartWhereUniqueInput
}

export type CartBookingCreateWithoutAccountInput = {
  id?: string
  refunded?: boolean
  paymentAmount: number
  cart: CartCreateOneWithoutCartBookingInput
  booking: BookingCreateOneWithoutCartBookingInput
}

export type CartBookingCreateManyWithoutAccountInput = {
  create?: Enumerable<CartBookingCreateWithoutAccountInput>
  connect?: Enumerable<CartBookingWhereUniqueInput>
}

export type AccountCreateWithoutEventParentsInput = {
  id?: string
  createdAt?: Date | string
  settings: string
  stripe_accountId?: string | null
  stripe_refreshToken?: string | null
  stripe_customerId?: string | null
  stripe_subscriptionStatus?: string | null
  owner: UserCreateOneWithoutAccountInput
  filters?: FilterCreateManyWithoutAccountInput | null
  CartBooking?: CartBookingCreateManyWithoutAccountInput | null
  Cart?: CartCreateManyWithoutAccountInput | null
}

export type AccountCreateOneWithoutEventParentsInput = {
  create?: AccountCreateWithoutEventParentsInput
  connect?: AccountWhereUniqueInput
}

export type AccountCreateWithoutFiltersInput = {
  id?: string
  createdAt?: Date | string
  settings: string
  stripe_accountId?: string | null
  stripe_refreshToken?: string | null
  stripe_customerId?: string | null
  stripe_subscriptionStatus?: string | null
  owner: UserCreateOneWithoutAccountInput
  eventParents?: EventParentCreateManyWithoutAccountInput | null
  CartBooking?: CartBookingCreateManyWithoutAccountInput | null
  Cart?: CartCreateManyWithoutAccountInput | null
}

export type AccountCreateOneWithoutFiltersInput = {
  create?: AccountCreateWithoutFiltersInput
  connect?: AccountWhereUniqueInput
}

export type FilterCreateWithoutEventsInput = {
  id?: string
  createdAt?: Date | string
  name: string
  description?: string | null
  type: FilterType
  account: AccountCreateOneWithoutFiltersInput
}

export type FilterCreateManyWithoutEventsInput = {
  create?: Enumerable<FilterCreateWithoutEventsInput>
  connect?: Enumerable<FilterWhereUniqueInput>
}

export type EventCreateWithoutEventParentsInput = {
  id?: string
  createdAt?: Date | string
  title: string
  description: string
  price: number
  spaces: number
  duration: number
  filters?: FilterCreateManyWithoutEventsInput | null
  eventExceptions?: EventExceptionCreateManyWithoutEventInput | null
}

export type EventCreateOneWithoutEventParentsInput = {
  create?: EventCreateWithoutEventParentsInput
  connect?: EventWhereUniqueInput
}

export type EventParentCreateWithoutCreatedByInput = {
  id?: string
  createdAt?: Date | string
  deletedAt?: Date | string | null
  isPublished: boolean
  rule: string
  account: AccountCreateOneWithoutEventParentsInput
  exceptions?: EventExceptionCreateManyWithoutParentInput | null
  cancellations?: EventCancellationCreateManyWithoutParentInput | null
  event: EventCreateOneWithoutEventParentsInput
}

export type EventParentCreateManyWithoutCreatedByInput = {
  create?: Enumerable<EventParentCreateWithoutCreatedByInput>
  connect?: Enumerable<EventParentWhereUniqueInput>
}

export type CartCreateWithoutUserInput = {
  id?: string
  createdAt?: Date | string
  cartReference: string
  refunded?: boolean
  paymentStatus?: PaymentStatus
  stripe_paymentIntentId?: string | null
  pendingItems: JsonValue
  cartBooking?: CartBookingCreateManyWithoutCartInput | null
  guest?: GuestCreateOneWithoutCartInput | null
  account: AccountCreateOneWithoutCartInput
}

export type CartCreateManyWithoutUserInput = {
  create?: Enumerable<CartCreateWithoutUserInput>
  connect?: Enumerable<CartWhereUniqueInput>
}

export type UserCreateWithoutBookingsInput = {
  id?: string
  createdAt?: Date | string
  auth0_userId: string
  isGuest?: boolean | null
  account?: AccountCreateOneWithoutOwnerInput | null
  eventParents?: EventParentCreateManyWithoutCreatedByInput | null
  Cart?: CartCreateManyWithoutUserInput | null
}

export type UserCreateOneWithoutBookingsInput = {
  create?: UserCreateWithoutBookingsInput
  connect?: UserWhereUniqueInput
}

export type BookingCreateWithoutEventExceptionInput = {
  id?: string
  createdAt?: Date | string
  spaces: number
  cancelled?: boolean
  user: UserCreateOneWithoutBookingsInput
  guest?: GuestCreateOneWithoutBookingInput | null
  cartBooking?: CartBookingCreateOneWithoutBookingInput | null
}

export type BookingCreateManyWithoutEventExceptionInput = {
  create?: Enumerable<BookingCreateWithoutEventExceptionInput>
  connect?: Enumerable<BookingWhereUniqueInput>
}

export type EventCreateWithoutEventExceptionsInput = {
  id?: string
  createdAt?: Date | string
  title: string
  description: string
  price: number
  spaces: number
  duration: number
  filters?: FilterCreateManyWithoutEventsInput | null
  eventParents?: EventParentCreateManyWithoutEventInput | null
}

export type EventCreateOneWithoutEventExceptionsInput = {
  create?: EventCreateWithoutEventExceptionsInput
  connect?: EventWhereUniqueInput
}

export type EventExceptionCreateWithoutParentInput = {
  id?: string
  createdAt?: Date | string
  originalDate: Date | string
  date: Date | string
  cancelled?: boolean
  bookings?: BookingCreateManyWithoutEventExceptionInput | null
  event: EventCreateOneWithoutEventExceptionsInput
}

export type EventExceptionCreateManyWithoutParentInput = {
  create?: Enumerable<EventExceptionCreateWithoutParentInput>
  connect?: Enumerable<EventExceptionWhereUniqueInput>
}

export type EventParentCreateWithoutAccountInput = {
  id?: string
  createdAt?: Date | string
  deletedAt?: Date | string | null
  isPublished: boolean
  rule: string
  createdBy: UserCreateOneWithoutEventParentsInput
  exceptions?: EventExceptionCreateManyWithoutParentInput | null
  cancellations?: EventCancellationCreateManyWithoutParentInput | null
  event: EventCreateOneWithoutEventParentsInput
}

export type EventParentCreateManyWithoutAccountInput = {
  create?: Enumerable<EventParentCreateWithoutAccountInput>
  connect?: Enumerable<EventParentWhereUniqueInput>
}

export type AccountCreateWithoutOwnerInput = {
  id?: string
  createdAt?: Date | string
  settings: string
  stripe_accountId?: string | null
  stripe_refreshToken?: string | null
  stripe_customerId?: string | null
  stripe_subscriptionStatus?: string | null
  eventParents?: EventParentCreateManyWithoutAccountInput | null
  filters?: FilterCreateManyWithoutAccountInput | null
  CartBooking?: CartBookingCreateManyWithoutAccountInput | null
  Cart?: CartCreateManyWithoutAccountInput | null
}

export type AccountCreateOneWithoutOwnerInput = {
  create?: AccountCreateWithoutOwnerInput
  connect?: AccountWhereUniqueInput
}

export type UserCreateWithoutEventParentsInput = {
  id?: string
  createdAt?: Date | string
  auth0_userId: string
  isGuest?: boolean | null
  bookings?: BookingCreateManyWithoutUserInput | null
  account?: AccountCreateOneWithoutOwnerInput | null
  Cart?: CartCreateManyWithoutUserInput | null
}

export type UserCreateOneWithoutEventParentsInput = {
  create?: UserCreateWithoutEventParentsInput
  connect?: UserWhereUniqueInput
}

export type EventParentCreateWithoutExceptionsInput = {
  id?: string
  createdAt?: Date | string
  deletedAt?: Date | string | null
  isPublished: boolean
  rule: string
  createdBy: UserCreateOneWithoutEventParentsInput
  account: AccountCreateOneWithoutEventParentsInput
  cancellations?: EventCancellationCreateManyWithoutParentInput | null
  event: EventCreateOneWithoutEventParentsInput
}

export type EventParentCreateOneWithoutExceptionsInput = {
  create?: EventParentCreateWithoutExceptionsInput
  connect?: EventParentWhereUniqueInput
}

export type EventExceptionCreateWithoutBookingsInput = {
  id?: string
  createdAt?: Date | string
  originalDate: Date | string
  date: Date | string
  cancelled?: boolean
  parent: EventParentCreateOneWithoutExceptionsInput
  event: EventCreateOneWithoutEventExceptionsInput
}

export type EventExceptionCreateOneWithoutBookingsInput = {
  create?: EventExceptionCreateWithoutBookingsInput
  connect?: EventExceptionWhereUniqueInput
}

export type BookingCreateWithoutUserInput = {
  id?: string
  createdAt?: Date | string
  spaces: number
  cancelled?: boolean
  eventException: EventExceptionCreateOneWithoutBookingsInput
  guest?: GuestCreateOneWithoutBookingInput | null
  cartBooking?: CartBookingCreateOneWithoutBookingInput | null
}

export type BookingCreateManyWithoutUserInput = {
  create?: Enumerable<BookingCreateWithoutUserInput>
  connect?: Enumerable<BookingWhereUniqueInput>
}

export type UserCreateWithoutAccountInput = {
  id?: string
  createdAt?: Date | string
  auth0_userId: string
  isGuest?: boolean | null
  bookings?: BookingCreateManyWithoutUserInput | null
  eventParents?: EventParentCreateManyWithoutCreatedByInput | null
  Cart?: CartCreateManyWithoutUserInput | null
}

export type UserCreateOneWithoutAccountInput = {
  create?: UserCreateWithoutAccountInput
  connect?: UserWhereUniqueInput
}

export type AccountCreateInput = {
  id?: string
  createdAt?: Date | string
  settings: string
  stripe_accountId?: string | null
  stripe_refreshToken?: string | null
  stripe_customerId?: string | null
  stripe_subscriptionStatus?: string | null
  owner: UserCreateOneWithoutAccountInput
  eventParents?: EventParentCreateManyWithoutAccountInput | null
  filters?: FilterCreateManyWithoutAccountInput | null
  CartBooking?: CartBookingCreateManyWithoutAccountInput | null
  Cart?: CartCreateManyWithoutAccountInput | null
}

export type EventCancellationUpdateWithoutParentDataInput = {
  id?: string
  createdAt?: Date | string
  originalDate?: Date | string
}

export type EventCancellationUpdateWithWhereUniqueWithoutParentInput = {
  where: EventCancellationWhereUniqueInput
  data: EventCancellationUpdateWithoutParentDataInput
}

export type EventCancellationScalarWhereInput = {
  id?: string | UUIDFilter
  createdAt?: Date | string | DateTimeFilter
  originalDate?: Date | string | DateTimeFilter
  parentId?: string | StringFilter
  AND?: Enumerable<EventCancellationScalarWhereInput>
  OR?: Array<EventCancellationScalarWhereInput>
  NOT?: Enumerable<EventCancellationScalarWhereInput>
}

export type EventCancellationUpdateManyDataInput = {
  id?: string
  createdAt?: Date | string
  originalDate?: Date | string
}

export type EventCancellationUpdateManyWithWhereNestedInput = {
  where: EventCancellationScalarWhereInput
  data: EventCancellationUpdateManyDataInput
}

export type EventCancellationUpsertWithWhereUniqueWithoutParentInput = {
  where: EventCancellationWhereUniqueInput
  update: EventCancellationUpdateWithoutParentDataInput
  create: EventCancellationCreateWithoutParentInput
}

export type EventCancellationUpdateManyWithoutParentInput = {
  create?: Enumerable<EventCancellationCreateWithoutParentInput>
  connect?: Enumerable<EventCancellationWhereUniqueInput>
  set?: Enumerable<EventCancellationWhereUniqueInput>
  disconnect?: Enumerable<EventCancellationWhereUniqueInput>
  delete?: Enumerable<EventCancellationWhereUniqueInput>
  update?: Enumerable<EventCancellationUpdateWithWhereUniqueWithoutParentInput>
  updateMany?: Enumerable<EventCancellationUpdateManyWithWhereNestedInput>
  deleteMany?: Enumerable<EventCancellationScalarWhereInput>
  upsert?: Enumerable<EventCancellationUpsertWithWhereUniqueWithoutParentInput>
}

export type EventParentUpdateWithoutEventDataInput = {
  id?: string
  createdAt?: Date | string
  deletedAt?: Date | string | null
  isPublished?: boolean
  rule?: string
  createdBy?: UserUpdateOneRequiredWithoutEventParentsInput
  account?: AccountUpdateOneRequiredWithoutEventParentsInput
  exceptions?: EventExceptionUpdateManyWithoutParentInput
  cancellations?: EventCancellationUpdateManyWithoutParentInput
}

export type EventParentUpdateWithWhereUniqueWithoutEventInput = {
  where: EventParentWhereUniqueInput
  data: EventParentUpdateWithoutEventDataInput
}

export type EventParentScalarWhereInput = {
  id?: string | UUIDFilter
  createdAt?: Date | string | DateTimeFilter
  deletedAt?: Date | string | NullableDateTimeFilter | null
  isPublished?: boolean | BooleanFilter
  rule?: string | StringFilter
  createdByUserId?: string | StringFilter
  accountId?: string | StringFilter
  exceptions?: EventExceptionFilter | null
  cancellations?: EventCancellationFilter | null
  eventId?: string | StringFilter
  AND?: Enumerable<EventParentScalarWhereInput>
  OR?: Array<EventParentScalarWhereInput>
  NOT?: Enumerable<EventParentScalarWhereInput>
}

export type EventParentUpdateManyDataInput = {
  id?: string
  createdAt?: Date | string
  deletedAt?: Date | string | null
  isPublished?: boolean
  rule?: string
}

export type EventParentUpdateManyWithWhereNestedInput = {
  where: EventParentScalarWhereInput
  data: EventParentUpdateManyDataInput
}

export type EventParentUpsertWithWhereUniqueWithoutEventInput = {
  where: EventParentWhereUniqueInput
  update: EventParentUpdateWithoutEventDataInput
  create: EventParentCreateWithoutEventInput
}

export type EventParentUpdateManyWithoutEventInput = {
  create?: Enumerable<EventParentCreateWithoutEventInput>
  connect?: Enumerable<EventParentWhereUniqueInput>
  set?: Enumerable<EventParentWhereUniqueInput>
  disconnect?: Enumerable<EventParentWhereUniqueInput>
  delete?: Enumerable<EventParentWhereUniqueInput>
  update?: Enumerable<EventParentUpdateWithWhereUniqueWithoutEventInput>
  updateMany?: Enumerable<EventParentUpdateManyWithWhereNestedInput>
  deleteMany?: Enumerable<EventParentScalarWhereInput>
  upsert?: Enumerable<EventParentUpsertWithWhereUniqueWithoutEventInput>
}

export type EventExceptionUpdateWithoutEventDataInput = {
  id?: string
  createdAt?: Date | string
  originalDate?: Date | string
  date?: Date | string
  cancelled?: boolean
  bookings?: BookingUpdateManyWithoutEventExceptionInput
  parent?: EventParentUpdateOneRequiredWithoutExceptionsInput
}

export type EventExceptionUpdateWithWhereUniqueWithoutEventInput = {
  where: EventExceptionWhereUniqueInput
  data: EventExceptionUpdateWithoutEventDataInput
}

export type EventExceptionScalarWhereInput = {
  id?: string | UUIDFilter
  createdAt?: Date | string | DateTimeFilter
  originalDate?: Date | string | DateTimeFilter
  date?: Date | string | DateTimeFilter
  cancelled?: boolean | BooleanFilter
  bookings?: BookingFilter | null
  parentId?: string | StringFilter
  eventId?: string | StringFilter
  AND?: Enumerable<EventExceptionScalarWhereInput>
  OR?: Array<EventExceptionScalarWhereInput>
  NOT?: Enumerable<EventExceptionScalarWhereInput>
}

export type EventExceptionUpdateManyDataInput = {
  id?: string
  createdAt?: Date | string
  originalDate?: Date | string
  date?: Date | string
  cancelled?: boolean
}

export type EventExceptionUpdateManyWithWhereNestedInput = {
  where: EventExceptionScalarWhereInput
  data: EventExceptionUpdateManyDataInput
}

export type EventExceptionUpsertWithWhereUniqueWithoutEventInput = {
  where: EventExceptionWhereUniqueInput
  update: EventExceptionUpdateWithoutEventDataInput
  create: EventExceptionCreateWithoutEventInput
}

export type EventExceptionUpdateManyWithoutEventInput = {
  create?: Enumerable<EventExceptionCreateWithoutEventInput>
  connect?: Enumerable<EventExceptionWhereUniqueInput>
  set?: Enumerable<EventExceptionWhereUniqueInput>
  disconnect?: Enumerable<EventExceptionWhereUniqueInput>
  delete?: Enumerable<EventExceptionWhereUniqueInput>
  update?: Enumerable<EventExceptionUpdateWithWhereUniqueWithoutEventInput>
  updateMany?: Enumerable<EventExceptionUpdateManyWithWhereNestedInput>
  deleteMany?: Enumerable<EventExceptionScalarWhereInput>
  upsert?: Enumerable<EventExceptionUpsertWithWhereUniqueWithoutEventInput>
}

export type EventUpdateWithoutFiltersDataInput = {
  id?: string
  createdAt?: Date | string
  title?: string
  description?: string
  price?: number
  spaces?: number
  duration?: number
  eventParents?: EventParentUpdateManyWithoutEventInput
  eventExceptions?: EventExceptionUpdateManyWithoutEventInput
}

export type EventUpdateWithWhereUniqueWithoutFiltersInput = {
  where: EventWhereUniqueInput
  data: EventUpdateWithoutFiltersDataInput
}

export type EventScalarWhereInput = {
  id?: string | UUIDFilter
  createdAt?: Date | string | DateTimeFilter
  title?: string | StringFilter
  description?: string | StringFilter
  price?: number | IntFilter
  spaces?: number | IntFilter
  duration?: number | FloatFilter
  filters?: FilterFilter | null
  eventParents?: EventParentFilter | null
  eventExceptions?: EventExceptionFilter | null
  AND?: Enumerable<EventScalarWhereInput>
  OR?: Array<EventScalarWhereInput>
  NOT?: Enumerable<EventScalarWhereInput>
}

export type EventUpdateManyDataInput = {
  id?: string
  createdAt?: Date | string
  title?: string
  description?: string
  price?: number
  spaces?: number
  duration?: number
}

export type EventUpdateManyWithWhereNestedInput = {
  where: EventScalarWhereInput
  data: EventUpdateManyDataInput
}

export type EventUpsertWithWhereUniqueWithoutFiltersInput = {
  where: EventWhereUniqueInput
  update: EventUpdateWithoutFiltersDataInput
  create: EventCreateWithoutFiltersInput
}

export type EventUpdateManyWithoutFiltersInput = {
  create?: Enumerable<EventCreateWithoutFiltersInput>
  connect?: Enumerable<EventWhereUniqueInput>
  set?: Enumerable<EventWhereUniqueInput>
  disconnect?: Enumerable<EventWhereUniqueInput>
  delete?: Enumerable<EventWhereUniqueInput>
  update?: Enumerable<EventUpdateWithWhereUniqueWithoutFiltersInput>
  updateMany?: Enumerable<EventUpdateManyWithWhereNestedInput>
  deleteMany?: Enumerable<EventScalarWhereInput>
  upsert?: Enumerable<EventUpsertWithWhereUniqueWithoutFiltersInput>
}

export type FilterUpdateWithoutAccountDataInput = {
  id?: string
  createdAt?: Date | string
  name?: string
  description?: string | null
  type?: FilterType
  events?: EventUpdateManyWithoutFiltersInput
}

export type FilterUpdateWithWhereUniqueWithoutAccountInput = {
  where: FilterWhereUniqueInput
  data: FilterUpdateWithoutAccountDataInput
}

export type FilterScalarWhereInput = {
  id?: string | UUIDFilter
  createdAt?: Date | string | DateTimeFilter
  name?: string | StringFilter
  description?: string | NullableStringFilter | null
  type?: FilterType | FilterTypeFilter
  accountId?: string | StringFilter
  events?: EventFilter | null
  AND?: Enumerable<FilterScalarWhereInput>
  OR?: Array<FilterScalarWhereInput>
  NOT?: Enumerable<FilterScalarWhereInput>
}

export type FilterUpdateManyDataInput = {
  id?: string
  createdAt?: Date | string
  name?: string
  description?: string | null
  type?: FilterType
}

export type FilterUpdateManyWithWhereNestedInput = {
  where: FilterScalarWhereInput
  data: FilterUpdateManyDataInput
}

export type FilterUpsertWithWhereUniqueWithoutAccountInput = {
  where: FilterWhereUniqueInput
  update: FilterUpdateWithoutAccountDataInput
  create: FilterCreateWithoutAccountInput
}

export type FilterUpdateManyWithoutAccountInput = {
  create?: Enumerable<FilterCreateWithoutAccountInput>
  connect?: Enumerable<FilterWhereUniqueInput>
  set?: Enumerable<FilterWhereUniqueInput>
  disconnect?: Enumerable<FilterWhereUniqueInput>
  delete?: Enumerable<FilterWhereUniqueInput>
  update?: Enumerable<FilterUpdateWithWhereUniqueWithoutAccountInput>
  updateMany?: Enumerable<FilterUpdateManyWithWhereNestedInput>
  deleteMany?: Enumerable<FilterScalarWhereInput>
  upsert?: Enumerable<FilterUpsertWithWhereUniqueWithoutAccountInput>
}

export type UserUpdateWithoutCartDataInput = {
  id?: string
  createdAt?: Date | string
  auth0_userId?: string
  isGuest?: boolean | null
  bookings?: BookingUpdateManyWithoutUserInput
  account?: AccountUpdateOneWithoutOwnerInput
  eventParents?: EventParentUpdateManyWithoutCreatedByInput
}

export type UserUpsertWithoutCartInput = {
  update: UserUpdateWithoutCartDataInput
  create: UserCreateWithoutCartInput
}

export type UserUpdateOneRequiredWithoutCartInput = {
  create?: UserCreateWithoutCartInput
  connect?: UserWhereUniqueInput
  update?: UserUpdateWithoutCartDataInput
  upsert?: UserUpsertWithoutCartInput
}

export type AccountUpdateWithoutCartDataInput = {
  id?: string
  createdAt?: Date | string
  settings?: string
  stripe_accountId?: string | null
  stripe_refreshToken?: string | null
  stripe_customerId?: string | null
  stripe_subscriptionStatus?: string | null
  owner?: UserUpdateOneRequiredWithoutAccountInput
  eventParents?: EventParentUpdateManyWithoutAccountInput
  filters?: FilterUpdateManyWithoutAccountInput
  CartBooking?: CartBookingUpdateManyWithoutAccountInput
}

export type AccountUpsertWithoutCartInput = {
  update: AccountUpdateWithoutCartDataInput
  create: AccountCreateWithoutCartInput
}

export type AccountUpdateOneRequiredWithoutCartInput = {
  create?: AccountCreateWithoutCartInput
  connect?: AccountWhereUniqueInput
  update?: AccountUpdateWithoutCartDataInput
  upsert?: AccountUpsertWithoutCartInput
}

export type CartUpdateWithoutGuestDataInput = {
  id?: string
  createdAt?: Date | string
  cartReference?: string
  refunded?: boolean
  paymentStatus?: PaymentStatus
  stripe_paymentIntentId?: string | null
  pendingItems?: JsonValue
  cartBooking?: CartBookingUpdateManyWithoutCartInput
  user?: UserUpdateOneRequiredWithoutCartInput
  account?: AccountUpdateOneRequiredWithoutCartInput
}

export type CartUpdateWithWhereUniqueWithoutGuestInput = {
  where: CartWhereUniqueInput
  data: CartUpdateWithoutGuestDataInput
}

export type CartScalarWhereInput = {
  id?: string | UUIDFilter
  createdAt?: Date | string | DateTimeFilter
  cartReference?: string | StringFilter
  refunded?: boolean | BooleanFilter
  paymentStatus?: PaymentStatus | PaymentStatusFilter
  stripe_paymentIntentId?: string | NullableStringFilter | null
  pendingItems?: JsonValue | JsonFilter
  cartBooking?: CartBookingFilter | null
  userId?: string | StringFilter
  guestId?: string | NullableStringFilter | null
  accountId?: string | StringFilter
  AND?: Enumerable<CartScalarWhereInput>
  OR?: Array<CartScalarWhereInput>
  NOT?: Enumerable<CartScalarWhereInput>
}

export type CartUpdateManyDataInput = {
  id?: string
  createdAt?: Date | string
  cartReference?: string
  refunded?: boolean
  paymentStatus?: PaymentStatus
  stripe_paymentIntentId?: string | null
  pendingItems?: JsonValue
}

export type CartUpdateManyWithWhereNestedInput = {
  where: CartScalarWhereInput
  data: CartUpdateManyDataInput
}

export type CartUpsertWithWhereUniqueWithoutGuestInput = {
  where: CartWhereUniqueInput
  update: CartUpdateWithoutGuestDataInput
  create: CartCreateWithoutGuestInput
}

export type CartUpdateManyWithoutGuestInput = {
  create?: Enumerable<CartCreateWithoutGuestInput>
  connect?: Enumerable<CartWhereUniqueInput>
  set?: Enumerable<CartWhereUniqueInput>
  disconnect?: Enumerable<CartWhereUniqueInput>
  delete?: Enumerable<CartWhereUniqueInput>
  update?: Enumerable<CartUpdateWithWhereUniqueWithoutGuestInput>
  updateMany?: Enumerable<CartUpdateManyWithWhereNestedInput>
  deleteMany?: Enumerable<CartScalarWhereInput>
  upsert?: Enumerable<CartUpsertWithWhereUniqueWithoutGuestInput>
}

export type GuestUpdateWithoutBookingDataInput = {
  id?: string
  email?: string
  phoneNumber?: string
  Cart?: CartUpdateManyWithoutGuestInput
}

export type GuestUpsertWithoutBookingInput = {
  update: GuestUpdateWithoutBookingDataInput
  create: GuestCreateWithoutBookingInput
}

export type GuestUpdateOneWithoutBookingInput = {
  create?: GuestCreateWithoutBookingInput
  connect?: GuestWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: GuestUpdateWithoutBookingDataInput
  upsert?: GuestUpsertWithoutBookingInput
}

export type BookingUpdateWithoutCartBookingDataInput = {
  id?: string
  createdAt?: Date | string
  spaces?: number
  cancelled?: boolean
  eventException?: EventExceptionUpdateOneRequiredWithoutBookingsInput
  user?: UserUpdateOneRequiredWithoutBookingsInput
  guest?: GuestUpdateOneWithoutBookingInput
}

export type BookingUpsertWithoutCartBookingInput = {
  update: BookingUpdateWithoutCartBookingDataInput
  create: BookingCreateWithoutCartBookingInput
}

export type BookingUpdateOneRequiredWithoutCartBookingInput = {
  create?: BookingCreateWithoutCartBookingInput
  connect?: BookingWhereUniqueInput
  update?: BookingUpdateWithoutCartBookingDataInput
  upsert?: BookingUpsertWithoutCartBookingInput
}

export type CartBookingUpdateWithoutCartDataInput = {
  id?: string
  refunded?: boolean
  paymentAmount?: number
  booking?: BookingUpdateOneRequiredWithoutCartBookingInput
  Account?: AccountUpdateOneWithoutCartBookingInput
}

export type CartBookingUpdateWithWhereUniqueWithoutCartInput = {
  where: CartBookingWhereUniqueInput
  data: CartBookingUpdateWithoutCartDataInput
}

export type CartBookingScalarWhereInput = {
  id?: string | UUIDFilter
  refunded?: boolean | BooleanFilter
  paymentAmount?: number | IntFilter
  cartId?: string | StringFilter
  bookingId?: string | StringFilter
  accountId?: string | NullableStringFilter | null
  AND?: Enumerable<CartBookingScalarWhereInput>
  OR?: Array<CartBookingScalarWhereInput>
  NOT?: Enumerable<CartBookingScalarWhereInput>
}

export type CartBookingUpdateManyDataInput = {
  id?: string
  refunded?: boolean
  paymentAmount?: number
}

export type CartBookingUpdateManyWithWhereNestedInput = {
  where: CartBookingScalarWhereInput
  data: CartBookingUpdateManyDataInput
}

export type CartBookingUpsertWithWhereUniqueWithoutCartInput = {
  where: CartBookingWhereUniqueInput
  update: CartBookingUpdateWithoutCartDataInput
  create: CartBookingCreateWithoutCartInput
}

export type CartBookingUpdateManyWithoutCartInput = {
  create?: Enumerable<CartBookingCreateWithoutCartInput>
  connect?: Enumerable<CartBookingWhereUniqueInput>
  set?: Enumerable<CartBookingWhereUniqueInput>
  disconnect?: Enumerable<CartBookingWhereUniqueInput>
  delete?: Enumerable<CartBookingWhereUniqueInput>
  update?: Enumerable<CartBookingUpdateWithWhereUniqueWithoutCartInput>
  updateMany?: Enumerable<CartBookingUpdateManyWithWhereNestedInput>
  deleteMany?: Enumerable<CartBookingScalarWhereInput>
  upsert?: Enumerable<CartBookingUpsertWithWhereUniqueWithoutCartInput>
}

export type CartUpdateWithoutAccountDataInput = {
  id?: string
  createdAt?: Date | string
  cartReference?: string
  refunded?: boolean
  paymentStatus?: PaymentStatus
  stripe_paymentIntentId?: string | null
  pendingItems?: JsonValue
  cartBooking?: CartBookingUpdateManyWithoutCartInput
  user?: UserUpdateOneRequiredWithoutCartInput
  guest?: GuestUpdateOneWithoutCartInput
}

export type CartUpdateWithWhereUniqueWithoutAccountInput = {
  where: CartWhereUniqueInput
  data: CartUpdateWithoutAccountDataInput
}

export type CartUpsertWithWhereUniqueWithoutAccountInput = {
  where: CartWhereUniqueInput
  update: CartUpdateWithoutAccountDataInput
  create: CartCreateWithoutAccountInput
}

export type CartUpdateManyWithoutAccountInput = {
  create?: Enumerable<CartCreateWithoutAccountInput>
  connect?: Enumerable<CartWhereUniqueInput>
  set?: Enumerable<CartWhereUniqueInput>
  disconnect?: Enumerable<CartWhereUniqueInput>
  delete?: Enumerable<CartWhereUniqueInput>
  update?: Enumerable<CartUpdateWithWhereUniqueWithoutAccountInput>
  updateMany?: Enumerable<CartUpdateManyWithWhereNestedInput>
  deleteMany?: Enumerable<CartScalarWhereInput>
  upsert?: Enumerable<CartUpsertWithWhereUniqueWithoutAccountInput>
}

export type AccountUpdateWithoutCartBookingDataInput = {
  id?: string
  createdAt?: Date | string
  settings?: string
  stripe_accountId?: string | null
  stripe_refreshToken?: string | null
  stripe_customerId?: string | null
  stripe_subscriptionStatus?: string | null
  owner?: UserUpdateOneRequiredWithoutAccountInput
  eventParents?: EventParentUpdateManyWithoutAccountInput
  filters?: FilterUpdateManyWithoutAccountInput
  Cart?: CartUpdateManyWithoutAccountInput
}

export type AccountUpsertWithoutCartBookingInput = {
  update: AccountUpdateWithoutCartBookingDataInput
  create: AccountCreateWithoutCartBookingInput
}

export type AccountUpdateOneWithoutCartBookingInput = {
  create?: AccountCreateWithoutCartBookingInput
  connect?: AccountWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: AccountUpdateWithoutCartBookingDataInput
  upsert?: AccountUpsertWithoutCartBookingInput
}

export type CartBookingUpdateWithoutBookingDataInput = {
  id?: string
  refunded?: boolean
  paymentAmount?: number
  cart?: CartUpdateOneRequiredWithoutCartBookingInput
  Account?: AccountUpdateOneWithoutCartBookingInput
}

export type CartBookingUpsertWithoutBookingInput = {
  update: CartBookingUpdateWithoutBookingDataInput
  create: CartBookingCreateWithoutBookingInput
}

export type CartBookingUpdateOneWithoutBookingInput = {
  create?: CartBookingCreateWithoutBookingInput
  connect?: CartBookingWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: CartBookingUpdateWithoutBookingDataInput
  upsert?: CartBookingUpsertWithoutBookingInput
}

export type BookingUpdateWithoutGuestDataInput = {
  id?: string
  createdAt?: Date | string
  spaces?: number
  cancelled?: boolean
  eventException?: EventExceptionUpdateOneRequiredWithoutBookingsInput
  user?: UserUpdateOneRequiredWithoutBookingsInput
  cartBooking?: CartBookingUpdateOneWithoutBookingInput
}

export type BookingUpdateWithWhereUniqueWithoutGuestInput = {
  where: BookingWhereUniqueInput
  data: BookingUpdateWithoutGuestDataInput
}

export type BookingScalarWhereInput = {
  id?: string | UUIDFilter
  createdAt?: Date | string | DateTimeFilter
  spaces?: number | IntFilter
  cancelled?: boolean | BooleanFilter
  eventExceptionId?: string | StringFilter
  userId?: string | StringFilter
  guestId?: string | NullableStringFilter | null
  AND?: Enumerable<BookingScalarWhereInput>
  OR?: Array<BookingScalarWhereInput>
  NOT?: Enumerable<BookingScalarWhereInput>
}

export type BookingUpdateManyDataInput = {
  id?: string
  createdAt?: Date | string
  spaces?: number
  cancelled?: boolean
}

export type BookingUpdateManyWithWhereNestedInput = {
  where: BookingScalarWhereInput
  data: BookingUpdateManyDataInput
}

export type BookingUpsertWithWhereUniqueWithoutGuestInput = {
  where: BookingWhereUniqueInput
  update: BookingUpdateWithoutGuestDataInput
  create: BookingCreateWithoutGuestInput
}

export type BookingUpdateManyWithoutGuestInput = {
  create?: Enumerable<BookingCreateWithoutGuestInput>
  connect?: Enumerable<BookingWhereUniqueInput>
  set?: Enumerable<BookingWhereUniqueInput>
  disconnect?: Enumerable<BookingWhereUniqueInput>
  delete?: Enumerable<BookingWhereUniqueInput>
  update?: Enumerable<BookingUpdateWithWhereUniqueWithoutGuestInput>
  updateMany?: Enumerable<BookingUpdateManyWithWhereNestedInput>
  deleteMany?: Enumerable<BookingScalarWhereInput>
  upsert?: Enumerable<BookingUpsertWithWhereUniqueWithoutGuestInput>
}

export type GuestUpdateWithoutCartDataInput = {
  id?: string
  email?: string
  phoneNumber?: string
  Booking?: BookingUpdateManyWithoutGuestInput
}

export type GuestUpsertWithoutCartInput = {
  update: GuestUpdateWithoutCartDataInput
  create: GuestCreateWithoutCartInput
}

export type GuestUpdateOneWithoutCartInput = {
  create?: GuestCreateWithoutCartInput
  connect?: GuestWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: GuestUpdateWithoutCartDataInput
  upsert?: GuestUpsertWithoutCartInput
}

export type CartUpdateWithoutCartBookingDataInput = {
  id?: string
  createdAt?: Date | string
  cartReference?: string
  refunded?: boolean
  paymentStatus?: PaymentStatus
  stripe_paymentIntentId?: string | null
  pendingItems?: JsonValue
  user?: UserUpdateOneRequiredWithoutCartInput
  guest?: GuestUpdateOneWithoutCartInput
  account?: AccountUpdateOneRequiredWithoutCartInput
}

export type CartUpsertWithoutCartBookingInput = {
  update: CartUpdateWithoutCartBookingDataInput
  create: CartCreateWithoutCartBookingInput
}

export type CartUpdateOneRequiredWithoutCartBookingInput = {
  create?: CartCreateWithoutCartBookingInput
  connect?: CartWhereUniqueInput
  update?: CartUpdateWithoutCartBookingDataInput
  upsert?: CartUpsertWithoutCartBookingInput
}

export type CartBookingUpdateWithoutAccountDataInput = {
  id?: string
  refunded?: boolean
  paymentAmount?: number
  cart?: CartUpdateOneRequiredWithoutCartBookingInput
  booking?: BookingUpdateOneRequiredWithoutCartBookingInput
}

export type CartBookingUpdateWithWhereUniqueWithoutAccountInput = {
  where: CartBookingWhereUniqueInput
  data: CartBookingUpdateWithoutAccountDataInput
}

export type CartBookingUpsertWithWhereUniqueWithoutAccountInput = {
  where: CartBookingWhereUniqueInput
  update: CartBookingUpdateWithoutAccountDataInput
  create: CartBookingCreateWithoutAccountInput
}

export type CartBookingUpdateManyWithoutAccountInput = {
  create?: Enumerable<CartBookingCreateWithoutAccountInput>
  connect?: Enumerable<CartBookingWhereUniqueInput>
  set?: Enumerable<CartBookingWhereUniqueInput>
  disconnect?: Enumerable<CartBookingWhereUniqueInput>
  delete?: Enumerable<CartBookingWhereUniqueInput>
  update?: Enumerable<CartBookingUpdateWithWhereUniqueWithoutAccountInput>
  updateMany?: Enumerable<CartBookingUpdateManyWithWhereNestedInput>
  deleteMany?: Enumerable<CartBookingScalarWhereInput>
  upsert?: Enumerable<CartBookingUpsertWithWhereUniqueWithoutAccountInput>
}

export type AccountUpdateWithoutEventParentsDataInput = {
  id?: string
  createdAt?: Date | string
  settings?: string
  stripe_accountId?: string | null
  stripe_refreshToken?: string | null
  stripe_customerId?: string | null
  stripe_subscriptionStatus?: string | null
  owner?: UserUpdateOneRequiredWithoutAccountInput
  filters?: FilterUpdateManyWithoutAccountInput
  CartBooking?: CartBookingUpdateManyWithoutAccountInput
  Cart?: CartUpdateManyWithoutAccountInput
}

export type AccountUpsertWithoutEventParentsInput = {
  update: AccountUpdateWithoutEventParentsDataInput
  create: AccountCreateWithoutEventParentsInput
}

export type AccountUpdateOneRequiredWithoutEventParentsInput = {
  create?: AccountCreateWithoutEventParentsInput
  connect?: AccountWhereUniqueInput
  update?: AccountUpdateWithoutEventParentsDataInput
  upsert?: AccountUpsertWithoutEventParentsInput
}

export type AccountUpdateWithoutFiltersDataInput = {
  id?: string
  createdAt?: Date | string
  settings?: string
  stripe_accountId?: string | null
  stripe_refreshToken?: string | null
  stripe_customerId?: string | null
  stripe_subscriptionStatus?: string | null
  owner?: UserUpdateOneRequiredWithoutAccountInput
  eventParents?: EventParentUpdateManyWithoutAccountInput
  CartBooking?: CartBookingUpdateManyWithoutAccountInput
  Cart?: CartUpdateManyWithoutAccountInput
}

export type AccountUpsertWithoutFiltersInput = {
  update: AccountUpdateWithoutFiltersDataInput
  create: AccountCreateWithoutFiltersInput
}

export type AccountUpdateOneRequiredWithoutFiltersInput = {
  create?: AccountCreateWithoutFiltersInput
  connect?: AccountWhereUniqueInput
  update?: AccountUpdateWithoutFiltersDataInput
  upsert?: AccountUpsertWithoutFiltersInput
}

export type FilterUpdateWithoutEventsDataInput = {
  id?: string
  createdAt?: Date | string
  name?: string
  description?: string | null
  type?: FilterType
  account?: AccountUpdateOneRequiredWithoutFiltersInput
}

export type FilterUpdateWithWhereUniqueWithoutEventsInput = {
  where: FilterWhereUniqueInput
  data: FilterUpdateWithoutEventsDataInput
}

export type FilterUpsertWithWhereUniqueWithoutEventsInput = {
  where: FilterWhereUniqueInput
  update: FilterUpdateWithoutEventsDataInput
  create: FilterCreateWithoutEventsInput
}

export type FilterUpdateManyWithoutEventsInput = {
  create?: Enumerable<FilterCreateWithoutEventsInput>
  connect?: Enumerable<FilterWhereUniqueInput>
  set?: Enumerable<FilterWhereUniqueInput>
  disconnect?: Enumerable<FilterWhereUniqueInput>
  delete?: Enumerable<FilterWhereUniqueInput>
  update?: Enumerable<FilterUpdateWithWhereUniqueWithoutEventsInput>
  updateMany?: Enumerable<FilterUpdateManyWithWhereNestedInput>
  deleteMany?: Enumerable<FilterScalarWhereInput>
  upsert?: Enumerable<FilterUpsertWithWhereUniqueWithoutEventsInput>
}

export type EventUpdateWithoutEventParentsDataInput = {
  id?: string
  createdAt?: Date | string
  title?: string
  description?: string
  price?: number
  spaces?: number
  duration?: number
  filters?: FilterUpdateManyWithoutEventsInput
  eventExceptions?: EventExceptionUpdateManyWithoutEventInput
}

export type EventUpsertWithoutEventParentsInput = {
  update: EventUpdateWithoutEventParentsDataInput
  create: EventCreateWithoutEventParentsInput
}

export type EventUpdateOneRequiredWithoutEventParentsInput = {
  create?: EventCreateWithoutEventParentsInput
  connect?: EventWhereUniqueInput
  update?: EventUpdateWithoutEventParentsDataInput
  upsert?: EventUpsertWithoutEventParentsInput
}

export type EventParentUpdateWithoutCreatedByDataInput = {
  id?: string
  createdAt?: Date | string
  deletedAt?: Date | string | null
  isPublished?: boolean
  rule?: string
  account?: AccountUpdateOneRequiredWithoutEventParentsInput
  exceptions?: EventExceptionUpdateManyWithoutParentInput
  cancellations?: EventCancellationUpdateManyWithoutParentInput
  event?: EventUpdateOneRequiredWithoutEventParentsInput
}

export type EventParentUpdateWithWhereUniqueWithoutCreatedByInput = {
  where: EventParentWhereUniqueInput
  data: EventParentUpdateWithoutCreatedByDataInput
}

export type EventParentUpsertWithWhereUniqueWithoutCreatedByInput = {
  where: EventParentWhereUniqueInput
  update: EventParentUpdateWithoutCreatedByDataInput
  create: EventParentCreateWithoutCreatedByInput
}

export type EventParentUpdateManyWithoutCreatedByInput = {
  create?: Enumerable<EventParentCreateWithoutCreatedByInput>
  connect?: Enumerable<EventParentWhereUniqueInput>
  set?: Enumerable<EventParentWhereUniqueInput>
  disconnect?: Enumerable<EventParentWhereUniqueInput>
  delete?: Enumerable<EventParentWhereUniqueInput>
  update?: Enumerable<EventParentUpdateWithWhereUniqueWithoutCreatedByInput>
  updateMany?: Enumerable<EventParentUpdateManyWithWhereNestedInput>
  deleteMany?: Enumerable<EventParentScalarWhereInput>
  upsert?: Enumerable<EventParentUpsertWithWhereUniqueWithoutCreatedByInput>
}

export type CartUpdateWithoutUserDataInput = {
  id?: string
  createdAt?: Date | string
  cartReference?: string
  refunded?: boolean
  paymentStatus?: PaymentStatus
  stripe_paymentIntentId?: string | null
  pendingItems?: JsonValue
  cartBooking?: CartBookingUpdateManyWithoutCartInput
  guest?: GuestUpdateOneWithoutCartInput
  account?: AccountUpdateOneRequiredWithoutCartInput
}

export type CartUpdateWithWhereUniqueWithoutUserInput = {
  where: CartWhereUniqueInput
  data: CartUpdateWithoutUserDataInput
}

export type CartUpsertWithWhereUniqueWithoutUserInput = {
  where: CartWhereUniqueInput
  update: CartUpdateWithoutUserDataInput
  create: CartCreateWithoutUserInput
}

export type CartUpdateManyWithoutUserInput = {
  create?: Enumerable<CartCreateWithoutUserInput>
  connect?: Enumerable<CartWhereUniqueInput>
  set?: Enumerable<CartWhereUniqueInput>
  disconnect?: Enumerable<CartWhereUniqueInput>
  delete?: Enumerable<CartWhereUniqueInput>
  update?: Enumerable<CartUpdateWithWhereUniqueWithoutUserInput>
  updateMany?: Enumerable<CartUpdateManyWithWhereNestedInput>
  deleteMany?: Enumerable<CartScalarWhereInput>
  upsert?: Enumerable<CartUpsertWithWhereUniqueWithoutUserInput>
}

export type UserUpdateWithoutBookingsDataInput = {
  id?: string
  createdAt?: Date | string
  auth0_userId?: string
  isGuest?: boolean | null
  account?: AccountUpdateOneWithoutOwnerInput
  eventParents?: EventParentUpdateManyWithoutCreatedByInput
  Cart?: CartUpdateManyWithoutUserInput
}

export type UserUpsertWithoutBookingsInput = {
  update: UserUpdateWithoutBookingsDataInput
  create: UserCreateWithoutBookingsInput
}

export type UserUpdateOneRequiredWithoutBookingsInput = {
  create?: UserCreateWithoutBookingsInput
  connect?: UserWhereUniqueInput
  update?: UserUpdateWithoutBookingsDataInput
  upsert?: UserUpsertWithoutBookingsInput
}

export type BookingUpdateWithoutEventExceptionDataInput = {
  id?: string
  createdAt?: Date | string
  spaces?: number
  cancelled?: boolean
  user?: UserUpdateOneRequiredWithoutBookingsInput
  guest?: GuestUpdateOneWithoutBookingInput
  cartBooking?: CartBookingUpdateOneWithoutBookingInput
}

export type BookingUpdateWithWhereUniqueWithoutEventExceptionInput = {
  where: BookingWhereUniqueInput
  data: BookingUpdateWithoutEventExceptionDataInput
}

export type BookingUpsertWithWhereUniqueWithoutEventExceptionInput = {
  where: BookingWhereUniqueInput
  update: BookingUpdateWithoutEventExceptionDataInput
  create: BookingCreateWithoutEventExceptionInput
}

export type BookingUpdateManyWithoutEventExceptionInput = {
  create?: Enumerable<BookingCreateWithoutEventExceptionInput>
  connect?: Enumerable<BookingWhereUniqueInput>
  set?: Enumerable<BookingWhereUniqueInput>
  disconnect?: Enumerable<BookingWhereUniqueInput>
  delete?: Enumerable<BookingWhereUniqueInput>
  update?: Enumerable<BookingUpdateWithWhereUniqueWithoutEventExceptionInput>
  updateMany?: Enumerable<BookingUpdateManyWithWhereNestedInput>
  deleteMany?: Enumerable<BookingScalarWhereInput>
  upsert?: Enumerable<BookingUpsertWithWhereUniqueWithoutEventExceptionInput>
}

export type EventUpdateWithoutEventExceptionsDataInput = {
  id?: string
  createdAt?: Date | string
  title?: string
  description?: string
  price?: number
  spaces?: number
  duration?: number
  filters?: FilterUpdateManyWithoutEventsInput
  eventParents?: EventParentUpdateManyWithoutEventInput
}

export type EventUpsertWithoutEventExceptionsInput = {
  update: EventUpdateWithoutEventExceptionsDataInput
  create: EventCreateWithoutEventExceptionsInput
}

export type EventUpdateOneRequiredWithoutEventExceptionsInput = {
  create?: EventCreateWithoutEventExceptionsInput
  connect?: EventWhereUniqueInput
  update?: EventUpdateWithoutEventExceptionsDataInput
  upsert?: EventUpsertWithoutEventExceptionsInput
}

export type EventExceptionUpdateWithoutParentDataInput = {
  id?: string
  createdAt?: Date | string
  originalDate?: Date | string
  date?: Date | string
  cancelled?: boolean
  bookings?: BookingUpdateManyWithoutEventExceptionInput
  event?: EventUpdateOneRequiredWithoutEventExceptionsInput
}

export type EventExceptionUpdateWithWhereUniqueWithoutParentInput = {
  where: EventExceptionWhereUniqueInput
  data: EventExceptionUpdateWithoutParentDataInput
}

export type EventExceptionUpsertWithWhereUniqueWithoutParentInput = {
  where: EventExceptionWhereUniqueInput
  update: EventExceptionUpdateWithoutParentDataInput
  create: EventExceptionCreateWithoutParentInput
}

export type EventExceptionUpdateManyWithoutParentInput = {
  create?: Enumerable<EventExceptionCreateWithoutParentInput>
  connect?: Enumerable<EventExceptionWhereUniqueInput>
  set?: Enumerable<EventExceptionWhereUniqueInput>
  disconnect?: Enumerable<EventExceptionWhereUniqueInput>
  delete?: Enumerable<EventExceptionWhereUniqueInput>
  update?: Enumerable<EventExceptionUpdateWithWhereUniqueWithoutParentInput>
  updateMany?: Enumerable<EventExceptionUpdateManyWithWhereNestedInput>
  deleteMany?: Enumerable<EventExceptionScalarWhereInput>
  upsert?: Enumerable<EventExceptionUpsertWithWhereUniqueWithoutParentInput>
}

export type EventParentUpdateWithoutAccountDataInput = {
  id?: string
  createdAt?: Date | string
  deletedAt?: Date | string | null
  isPublished?: boolean
  rule?: string
  createdBy?: UserUpdateOneRequiredWithoutEventParentsInput
  exceptions?: EventExceptionUpdateManyWithoutParentInput
  cancellations?: EventCancellationUpdateManyWithoutParentInput
  event?: EventUpdateOneRequiredWithoutEventParentsInput
}

export type EventParentUpdateWithWhereUniqueWithoutAccountInput = {
  where: EventParentWhereUniqueInput
  data: EventParentUpdateWithoutAccountDataInput
}

export type EventParentUpsertWithWhereUniqueWithoutAccountInput = {
  where: EventParentWhereUniqueInput
  update: EventParentUpdateWithoutAccountDataInput
  create: EventParentCreateWithoutAccountInput
}

export type EventParentUpdateManyWithoutAccountInput = {
  create?: Enumerable<EventParentCreateWithoutAccountInput>
  connect?: Enumerable<EventParentWhereUniqueInput>
  set?: Enumerable<EventParentWhereUniqueInput>
  disconnect?: Enumerable<EventParentWhereUniqueInput>
  delete?: Enumerable<EventParentWhereUniqueInput>
  update?: Enumerable<EventParentUpdateWithWhereUniqueWithoutAccountInput>
  updateMany?: Enumerable<EventParentUpdateManyWithWhereNestedInput>
  deleteMany?: Enumerable<EventParentScalarWhereInput>
  upsert?: Enumerable<EventParentUpsertWithWhereUniqueWithoutAccountInput>
}

export type AccountUpdateWithoutOwnerDataInput = {
  id?: string
  createdAt?: Date | string
  settings?: string
  stripe_accountId?: string | null
  stripe_refreshToken?: string | null
  stripe_customerId?: string | null
  stripe_subscriptionStatus?: string | null
  eventParents?: EventParentUpdateManyWithoutAccountInput
  filters?: FilterUpdateManyWithoutAccountInput
  CartBooking?: CartBookingUpdateManyWithoutAccountInput
  Cart?: CartUpdateManyWithoutAccountInput
}

export type AccountUpsertWithoutOwnerInput = {
  update: AccountUpdateWithoutOwnerDataInput
  create: AccountCreateWithoutOwnerInput
}

export type AccountUpdateOneWithoutOwnerInput = {
  create?: AccountCreateWithoutOwnerInput
  connect?: AccountWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: AccountUpdateWithoutOwnerDataInput
  upsert?: AccountUpsertWithoutOwnerInput
}

export type UserUpdateWithoutEventParentsDataInput = {
  id?: string
  createdAt?: Date | string
  auth0_userId?: string
  isGuest?: boolean | null
  bookings?: BookingUpdateManyWithoutUserInput
  account?: AccountUpdateOneWithoutOwnerInput
  Cart?: CartUpdateManyWithoutUserInput
}

export type UserUpsertWithoutEventParentsInput = {
  update: UserUpdateWithoutEventParentsDataInput
  create: UserCreateWithoutEventParentsInput
}

export type UserUpdateOneRequiredWithoutEventParentsInput = {
  create?: UserCreateWithoutEventParentsInput
  connect?: UserWhereUniqueInput
  update?: UserUpdateWithoutEventParentsDataInput
  upsert?: UserUpsertWithoutEventParentsInput
}

export type EventParentUpdateWithoutExceptionsDataInput = {
  id?: string
  createdAt?: Date | string
  deletedAt?: Date | string | null
  isPublished?: boolean
  rule?: string
  createdBy?: UserUpdateOneRequiredWithoutEventParentsInput
  account?: AccountUpdateOneRequiredWithoutEventParentsInput
  cancellations?: EventCancellationUpdateManyWithoutParentInput
  event?: EventUpdateOneRequiredWithoutEventParentsInput
}

export type EventParentUpsertWithoutExceptionsInput = {
  update: EventParentUpdateWithoutExceptionsDataInput
  create: EventParentCreateWithoutExceptionsInput
}

export type EventParentUpdateOneRequiredWithoutExceptionsInput = {
  create?: EventParentCreateWithoutExceptionsInput
  connect?: EventParentWhereUniqueInput
  update?: EventParentUpdateWithoutExceptionsDataInput
  upsert?: EventParentUpsertWithoutExceptionsInput
}

export type EventExceptionUpdateWithoutBookingsDataInput = {
  id?: string
  createdAt?: Date | string
  originalDate?: Date | string
  date?: Date | string
  cancelled?: boolean
  parent?: EventParentUpdateOneRequiredWithoutExceptionsInput
  event?: EventUpdateOneRequiredWithoutEventExceptionsInput
}

export type EventExceptionUpsertWithoutBookingsInput = {
  update: EventExceptionUpdateWithoutBookingsDataInput
  create: EventExceptionCreateWithoutBookingsInput
}

export type EventExceptionUpdateOneRequiredWithoutBookingsInput = {
  create?: EventExceptionCreateWithoutBookingsInput
  connect?: EventExceptionWhereUniqueInput
  update?: EventExceptionUpdateWithoutBookingsDataInput
  upsert?: EventExceptionUpsertWithoutBookingsInput
}

export type BookingUpdateWithoutUserDataInput = {
  id?: string
  createdAt?: Date | string
  spaces?: number
  cancelled?: boolean
  eventException?: EventExceptionUpdateOneRequiredWithoutBookingsInput
  guest?: GuestUpdateOneWithoutBookingInput
  cartBooking?: CartBookingUpdateOneWithoutBookingInput
}

export type BookingUpdateWithWhereUniqueWithoutUserInput = {
  where: BookingWhereUniqueInput
  data: BookingUpdateWithoutUserDataInput
}

export type BookingUpsertWithWhereUniqueWithoutUserInput = {
  where: BookingWhereUniqueInput
  update: BookingUpdateWithoutUserDataInput
  create: BookingCreateWithoutUserInput
}

export type BookingUpdateManyWithoutUserInput = {
  create?: Enumerable<BookingCreateWithoutUserInput>
  connect?: Enumerable<BookingWhereUniqueInput>
  set?: Enumerable<BookingWhereUniqueInput>
  disconnect?: Enumerable<BookingWhereUniqueInput>
  delete?: Enumerable<BookingWhereUniqueInput>
  update?: Enumerable<BookingUpdateWithWhereUniqueWithoutUserInput>
  updateMany?: Enumerable<BookingUpdateManyWithWhereNestedInput>
  deleteMany?: Enumerable<BookingScalarWhereInput>
  upsert?: Enumerable<BookingUpsertWithWhereUniqueWithoutUserInput>
}

export type UserUpdateWithoutAccountDataInput = {
  id?: string
  createdAt?: Date | string
  auth0_userId?: string
  isGuest?: boolean | null
  bookings?: BookingUpdateManyWithoutUserInput
  eventParents?: EventParentUpdateManyWithoutCreatedByInput
  Cart?: CartUpdateManyWithoutUserInput
}

export type UserUpsertWithoutAccountInput = {
  update: UserUpdateWithoutAccountDataInput
  create: UserCreateWithoutAccountInput
}

export type UserUpdateOneRequiredWithoutAccountInput = {
  create?: UserCreateWithoutAccountInput
  connect?: UserWhereUniqueInput
  update?: UserUpdateWithoutAccountDataInput
  upsert?: UserUpsertWithoutAccountInput
}

export type AccountUpdateInput = {
  id?: string
  createdAt?: Date | string
  settings?: string
  stripe_accountId?: string | null
  stripe_refreshToken?: string | null
  stripe_customerId?: string | null
  stripe_subscriptionStatus?: string | null
  owner?: UserUpdateOneRequiredWithoutAccountInput
  eventParents?: EventParentUpdateManyWithoutAccountInput
  filters?: FilterUpdateManyWithoutAccountInput
  CartBooking?: CartBookingUpdateManyWithoutAccountInput
  Cart?: CartUpdateManyWithoutAccountInput
}

export type AccountUpdateManyMutationInput = {
  id?: string
  createdAt?: Date | string
  settings?: string
  stripe_accountId?: string | null
  stripe_refreshToken?: string | null
  stripe_customerId?: string | null
  stripe_subscriptionStatus?: string | null
}

export type UserCreateInput = {
  id?: string
  createdAt?: Date | string
  auth0_userId: string
  isGuest?: boolean | null
  bookings?: BookingCreateManyWithoutUserInput | null
  account?: AccountCreateOneWithoutOwnerInput | null
  eventParents?: EventParentCreateManyWithoutCreatedByInput | null
  Cart?: CartCreateManyWithoutUserInput | null
}

export type UserUpdateInput = {
  id?: string
  createdAt?: Date | string
  auth0_userId?: string
  isGuest?: boolean | null
  bookings?: BookingUpdateManyWithoutUserInput
  account?: AccountUpdateOneWithoutOwnerInput
  eventParents?: EventParentUpdateManyWithoutCreatedByInput
  Cart?: CartUpdateManyWithoutUserInput
}

export type UserUpdateManyMutationInput = {
  id?: string
  createdAt?: Date | string
  auth0_userId?: string
  isGuest?: boolean | null
}

export type EventCreateInput = {
  id?: string
  createdAt?: Date | string
  title: string
  description: string
  price: number
  spaces: number
  duration: number
  filters?: FilterCreateManyWithoutEventsInput | null
  eventParents?: EventParentCreateManyWithoutEventInput | null
  eventExceptions?: EventExceptionCreateManyWithoutEventInput | null
}

export type EventUpdateInput = {
  id?: string
  createdAt?: Date | string
  title?: string
  description?: string
  price?: number
  spaces?: number
  duration?: number
  filters?: FilterUpdateManyWithoutEventsInput
  eventParents?: EventParentUpdateManyWithoutEventInput
  eventExceptions?: EventExceptionUpdateManyWithoutEventInput
}

export type EventUpdateManyMutationInput = {
  id?: string
  createdAt?: Date | string
  title?: string
  description?: string
  price?: number
  spaces?: number
  duration?: number
}

export type EventParentCreateInput = {
  id?: string
  createdAt?: Date | string
  deletedAt?: Date | string | null
  isPublished: boolean
  rule: string
  createdBy: UserCreateOneWithoutEventParentsInput
  account: AccountCreateOneWithoutEventParentsInput
  exceptions?: EventExceptionCreateManyWithoutParentInput | null
  cancellations?: EventCancellationCreateManyWithoutParentInput | null
  event: EventCreateOneWithoutEventParentsInput
}

export type EventParentUpdateInput = {
  id?: string
  createdAt?: Date | string
  deletedAt?: Date | string | null
  isPublished?: boolean
  rule?: string
  createdBy?: UserUpdateOneRequiredWithoutEventParentsInput
  account?: AccountUpdateOneRequiredWithoutEventParentsInput
  exceptions?: EventExceptionUpdateManyWithoutParentInput
  cancellations?: EventCancellationUpdateManyWithoutParentInput
  event?: EventUpdateOneRequiredWithoutEventParentsInput
}

export type EventParentUpdateManyMutationInput = {
  id?: string
  createdAt?: Date | string
  deletedAt?: Date | string | null
  isPublished?: boolean
  rule?: string
}

export type EventExceptionCreateInput = {
  id?: string
  createdAt?: Date | string
  originalDate: Date | string
  date: Date | string
  cancelled?: boolean
  bookings?: BookingCreateManyWithoutEventExceptionInput | null
  parent: EventParentCreateOneWithoutExceptionsInput
  event: EventCreateOneWithoutEventExceptionsInput
}

export type EventExceptionUpdateInput = {
  id?: string
  createdAt?: Date | string
  originalDate?: Date | string
  date?: Date | string
  cancelled?: boolean
  bookings?: BookingUpdateManyWithoutEventExceptionInput
  parent?: EventParentUpdateOneRequiredWithoutExceptionsInput
  event?: EventUpdateOneRequiredWithoutEventExceptionsInput
}

export type EventExceptionUpdateManyMutationInput = {
  id?: string
  createdAt?: Date | string
  originalDate?: Date | string
  date?: Date | string
  cancelled?: boolean
}

export type EventParentCreateWithoutCancellationsInput = {
  id?: string
  createdAt?: Date | string
  deletedAt?: Date | string | null
  isPublished: boolean
  rule: string
  createdBy: UserCreateOneWithoutEventParentsInput
  account: AccountCreateOneWithoutEventParentsInput
  exceptions?: EventExceptionCreateManyWithoutParentInput | null
  event: EventCreateOneWithoutEventParentsInput
}

export type EventParentCreateOneWithoutCancellationsInput = {
  create?: EventParentCreateWithoutCancellationsInput
  connect?: EventParentWhereUniqueInput
}

export type EventCancellationCreateInput = {
  id?: string
  createdAt?: Date | string
  originalDate: Date | string
  parent: EventParentCreateOneWithoutCancellationsInput
}

export type EventParentUpdateWithoutCancellationsDataInput = {
  id?: string
  createdAt?: Date | string
  deletedAt?: Date | string | null
  isPublished?: boolean
  rule?: string
  createdBy?: UserUpdateOneRequiredWithoutEventParentsInput
  account?: AccountUpdateOneRequiredWithoutEventParentsInput
  exceptions?: EventExceptionUpdateManyWithoutParentInput
  event?: EventUpdateOneRequiredWithoutEventParentsInput
}

export type EventParentUpsertWithoutCancellationsInput = {
  update: EventParentUpdateWithoutCancellationsDataInput
  create: EventParentCreateWithoutCancellationsInput
}

export type EventParentUpdateOneRequiredWithoutCancellationsInput = {
  create?: EventParentCreateWithoutCancellationsInput
  connect?: EventParentWhereUniqueInput
  update?: EventParentUpdateWithoutCancellationsDataInput
  upsert?: EventParentUpsertWithoutCancellationsInput
}

export type EventCancellationUpdateInput = {
  id?: string
  createdAt?: Date | string
  originalDate?: Date | string
  parent?: EventParentUpdateOneRequiredWithoutCancellationsInput
}

export type EventCancellationUpdateManyMutationInput = {
  id?: string
  createdAt?: Date | string
  originalDate?: Date | string
}

export type FilterCreateInput = {
  id?: string
  createdAt?: Date | string
  name: string
  description?: string | null
  type: FilterType
  account: AccountCreateOneWithoutFiltersInput
  events?: EventCreateManyWithoutFiltersInput | null
}

export type FilterUpdateInput = {
  id?: string
  createdAt?: Date | string
  name?: string
  description?: string | null
  type?: FilterType
  account?: AccountUpdateOneRequiredWithoutFiltersInput
  events?: EventUpdateManyWithoutFiltersInput
}

export type FilterUpdateManyMutationInput = {
  id?: string
  createdAt?: Date | string
  name?: string
  description?: string | null
  type?: FilterType
}

export type BookingCreateInput = {
  id?: string
  createdAt?: Date | string
  spaces: number
  cancelled?: boolean
  eventException: EventExceptionCreateOneWithoutBookingsInput
  user: UserCreateOneWithoutBookingsInput
  guest?: GuestCreateOneWithoutBookingInput | null
  cartBooking?: CartBookingCreateOneWithoutBookingInput | null
}

export type BookingUpdateInput = {
  id?: string
  createdAt?: Date | string
  spaces?: number
  cancelled?: boolean
  eventException?: EventExceptionUpdateOneRequiredWithoutBookingsInput
  user?: UserUpdateOneRequiredWithoutBookingsInput
  guest?: GuestUpdateOneWithoutBookingInput
  cartBooking?: CartBookingUpdateOneWithoutBookingInput
}

export type BookingUpdateManyMutationInput = {
  id?: string
  createdAt?: Date | string
  spaces?: number
  cancelled?: boolean
}

export type GuestCreateInput = {
  id?: string
  email: string
  phoneNumber: string
  Booking?: BookingCreateManyWithoutGuestInput | null
  Cart?: CartCreateManyWithoutGuestInput | null
}

export type GuestUpdateInput = {
  id?: string
  email?: string
  phoneNumber?: string
  Booking?: BookingUpdateManyWithoutGuestInput
  Cart?: CartUpdateManyWithoutGuestInput
}

export type GuestUpdateManyMutationInput = {
  id?: string
  email?: string
  phoneNumber?: string
}

export type CartCreateInput = {
  id?: string
  createdAt?: Date | string
  cartReference: string
  refunded?: boolean
  paymentStatus?: PaymentStatus
  stripe_paymentIntentId?: string | null
  pendingItems: JsonValue
  cartBooking?: CartBookingCreateManyWithoutCartInput | null
  user: UserCreateOneWithoutCartInput
  guest?: GuestCreateOneWithoutCartInput | null
  account: AccountCreateOneWithoutCartInput
}

export type CartUpdateInput = {
  id?: string
  createdAt?: Date | string
  cartReference?: string
  refunded?: boolean
  paymentStatus?: PaymentStatus
  stripe_paymentIntentId?: string | null
  pendingItems?: JsonValue
  cartBooking?: CartBookingUpdateManyWithoutCartInput
  user?: UserUpdateOneRequiredWithoutCartInput
  guest?: GuestUpdateOneWithoutCartInput
  account?: AccountUpdateOneRequiredWithoutCartInput
}

export type CartUpdateManyMutationInput = {
  id?: string
  createdAt?: Date | string
  cartReference?: string
  refunded?: boolean
  paymentStatus?: PaymentStatus
  stripe_paymentIntentId?: string | null
  pendingItems?: JsonValue
}

export type CartBookingCreateInput = {
  id?: string
  refunded?: boolean
  paymentAmount: number
  cart: CartCreateOneWithoutCartBookingInput
  booking: BookingCreateOneWithoutCartBookingInput
  Account?: AccountCreateOneWithoutCartBookingInput | null
}

export type CartBookingUpdateInput = {
  id?: string
  refunded?: boolean
  paymentAmount?: number
  cart?: CartUpdateOneRequiredWithoutCartBookingInput
  booking?: BookingUpdateOneRequiredWithoutCartBookingInput
  Account?: AccountUpdateOneWithoutCartBookingInput
}

export type CartBookingUpdateManyMutationInput = {
  id?: string
  refunded?: boolean
  paymentAmount?: number
}

export type UUIDFilter = {
  equals?: string
  not?: string | UUIDFilter
  in?: Enumerable<string>
  notIn?: Enumerable<string>
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
}

export type DateTimeFilter = {
  equals?: Date | string
  not?: Date | string | DateTimeFilter
  in?: Enumerable<Date | string>
  notIn?: Enumerable<Date | string>
  lt?: Date | string
  lte?: Date | string
  gt?: Date | string
  gte?: Date | string
}

export type StringFilter = {
  equals?: string
  not?: string | StringFilter
  in?: Enumerable<string>
  notIn?: Enumerable<string>
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
}

export type NullableStringFilter = {
  equals?: string | null
  not?: string | null | NullableStringFilter
  in?: Enumerable<string> | null
  notIn?: Enumerable<string> | null
  lt?: string | null
  lte?: string | null
  gt?: string | null
  gte?: string | null
  contains?: string | null
  startsWith?: string | null
  endsWith?: string | null
}

export type FilterTypeFilter = {
  equals?: FilterType
  not?: FilterType | FilterTypeFilter
  in?: Enumerable<FilterType>
  notIn?: Enumerable<FilterType>
}

export type EventFilter = {
  every?: EventWhereInput
  some?: EventWhereInput
  none?: EventWhereInput
}

export type IntFilter = {
  equals?: number
  not?: number | IntFilter
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
}

export type FloatFilter = {
  equals?: number
  not?: number | FloatFilter
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
}

export type FilterFilter = {
  every?: FilterWhereInput
  some?: FilterWhereInput
  none?: FilterWhereInput
}

export type EventParentFilter = {
  every?: EventParentWhereInput
  some?: EventParentWhereInput
  none?: EventParentWhereInput
}

export type EventExceptionFilter = {
  every?: EventExceptionWhereInput
  some?: EventExceptionWhereInput
  none?: EventExceptionWhereInput
}

export type NullableDateTimeFilter = {
  equals?: Date | string | null
  not?: Date | string | null | NullableDateTimeFilter
  in?: Enumerable<Date | string> | null
  notIn?: Enumerable<Date | string> | null
  lt?: Date | string | null
  lte?: Date | string | null
  gt?: Date | string | null
  gte?: Date | string | null
}

export type BooleanFilter = {
  equals?: boolean
  not?: boolean | BooleanFilter
}

export type EventCancellationFilter = {
  every?: EventCancellationWhereInput
  some?: EventCancellationWhereInput
  none?: EventCancellationWhereInput
}

export type BookingFilter = {
  every?: BookingWhereInput
  some?: BookingWhereInput
  none?: BookingWhereInput
}

export type PaymentStatusFilter = {
  equals?: PaymentStatus
  not?: PaymentStatus | PaymentStatusFilter
  in?: Enumerable<PaymentStatus>
  notIn?: Enumerable<PaymentStatus>
}

export type JsonFilter = {

}

export type CartBookingFilter = {
  every?: CartBookingWhereInput
  some?: CartBookingWhereInput
  none?: CartBookingWhereInput
}

export type CartFilter = {
  every?: CartWhereInput
  some?: CartWhereInput
  none?: CartWhereInput
}

export type NullableBooleanFilter = {
  equals?: boolean | null
  not?: boolean | null | NullableBooleanFilter
}

export type AccountOrderByInput = {
  id?: OrderByArg | null
  createdAt?: OrderByArg | null
  settings?: OrderByArg | null
  stripe_accountId?: OrderByArg | null
  stripe_refreshToken?: OrderByArg | null
  stripe_customerId?: OrderByArg | null
  stripe_subscriptionStatus?: OrderByArg | null
  ownerId?: OrderByArg | null
}

export type BookingOrderByInput = {
  id?: OrderByArg | null
  createdAt?: OrderByArg | null
  spaces?: OrderByArg | null
  cancelled?: OrderByArg | null
  eventExceptionId?: OrderByArg | null
  userId?: OrderByArg | null
  guestId?: OrderByArg | null
}

export type EventExceptionOrderByInput = {
  id?: OrderByArg | null
  createdAt?: OrderByArg | null
  originalDate?: OrderByArg | null
  date?: OrderByArg | null
  cancelled?: OrderByArg | null
  parentId?: OrderByArg | null
  eventId?: OrderByArg | null
}

export type EventCancellationOrderByInput = {
  id?: OrderByArg | null
  createdAt?: OrderByArg | null
  originalDate?: OrderByArg | null
  parentId?: OrderByArg | null
}

export type FilterOrderByInput = {
  id?: OrderByArg | null
  createdAt?: OrderByArg | null
  name?: OrderByArg | null
  description?: OrderByArg | null
  type?: OrderByArg | null
  accountId?: OrderByArg | null
}

export type EventOrderByInput = {
  id?: OrderByArg | null
  createdAt?: OrderByArg | null
  title?: OrderByArg | null
  description?: OrderByArg | null
  price?: OrderByArg | null
  spaces?: OrderByArg | null
  duration?: OrderByArg | null
}

export type EventParentOrderByInput = {
  id?: OrderByArg | null
  createdAt?: OrderByArg | null
  deletedAt?: OrderByArg | null
  isPublished?: OrderByArg | null
  rule?: OrderByArg | null
  createdByUserId?: OrderByArg | null
  accountId?: OrderByArg | null
  eventId?: OrderByArg | null
}

export type CartOrderByInput = {
  id?: OrderByArg | null
  createdAt?: OrderByArg | null
  cartReference?: OrderByArg | null
  refunded?: OrderByArg | null
  paymentStatus?: OrderByArg | null
  stripe_paymentIntentId?: OrderByArg | null
  pendingItems?: OrderByArg | null
  userId?: OrderByArg | null
  guestId?: OrderByArg | null
  accountId?: OrderByArg | null
}

export type CartBookingOrderByInput = {
  id?: OrderByArg | null
  refunded?: OrderByArg | null
  paymentAmount?: OrderByArg | null
  cartId?: OrderByArg | null
  bookingId?: OrderByArg | null
  accountId?: OrderByArg | null
}

export type UserOrderByInput = {
  id?: OrderByArg | null
  createdAt?: OrderByArg | null
  auth0_userId?: OrderByArg | null
  isGuest?: OrderByArg | null
}

export type GuestOrderByInput = {
  id?: OrderByArg | null
  email?: OrderByArg | null
  phoneNumber?: OrderByArg | null
}

/**
 * Batch Payload for updateMany & deleteMany
 */

export type BatchPayload = {
  count: number
}

/**
 * DMMF
 */
export declare const dmmf: DMMF.Document;
export {};
